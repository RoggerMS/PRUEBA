"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useNotifications.ts":
/*!***************************************!*\
  !*** ./src/hooks/useNotifications.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useNotificationPreferences: function() { return /* binding */ useNotificationPreferences; },\n/* harmony export */   useNotifications: function() { return /* binding */ useNotifications; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/react */ \"(app-pages-browser)/./node_modules/next-auth/react/index.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ useNotifications,useNotificationPreferences auto */ \n\n\nfunction useNotifications() {\n    var _session_user, _session_user1, _session_user2, _session_user3;\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_1__.useSession)();\n    const [notifications, setNotifications] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [unreadCount, setUnreadCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [eventSource, setEventSource] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Fetch notifications from API\n    const fetchNotifications = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return;\n        try {\n            const response = await fetch(\"/api/notifications\");\n            if (response.ok) {\n                const data = await response.json();\n                setNotifications(data.notifications || []);\n                setUnreadCount(data.unreadCount || 0);\n            }\n        } catch (error) {\n            console.error(\"Error fetching notifications:\", error);\n        }\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id\n    ]);\n    // Mark notification as read\n    const markAsRead = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (notificationId)=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return;\n        try {\n            const response = await fetch(\"/api/notifications/\".concat(notificationId, \"/read\"), {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                setNotifications((prev)=>prev.map((notification)=>notification.id === notificationId ? {\n                            ...notification,\n                            read: true\n                        } : notification));\n                setUnreadCount((prev)=>Math.max(0, prev - 1));\n            }\n        } catch (error) {\n            console.error(\"Error marking notification as read:\", error);\n        }\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user1 = session.user) === null || _session_user1 === void 0 ? void 0 : _session_user1.id\n    ]);\n    // Mark all notifications as read\n    const markAllAsRead = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return;\n        try {\n            const response = await fetch(\"/api/notifications/read-all\", {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                setNotifications((prev)=>prev.map((notification)=>({\n                            ...notification,\n                            read: true\n                        })));\n                setUnreadCount(0);\n            }\n        } catch (error) {\n            console.error(\"Error marking all notifications as read:\", error);\n        }\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user2 = session.user) === null || _session_user2 === void 0 ? void 0 : _session_user2.id\n    ]);\n    // Setup Server-Sent Events for real-time notifications\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) {\n            if (eventSource) {\n                eventSource.close();\n                setEventSource(null);\n                setIsConnected(false);\n            }\n            return;\n        }\n        // Create EventSource for real-time notifications\n        const es = new EventSource(\"/api/notifications/stream?userId=\".concat(session.user.id));\n        es.onopen = ()=>{\n            setIsConnected(true);\n            console.log(\"Notifications stream connected\");\n        };\n        es.onmessage = (event)=>{\n            try {\n                const data = JSON.parse(event.data);\n                if (data.type === \"notification\") {\n                    const newNotification = data.data;\n                    // Add to notifications list\n                    setNotifications((prev)=>[\n                            newNotification,\n                            ...prev.slice(0, 49)\n                        ]); // Keep only 50 notifications\n                    setUnreadCount((prev)=>prev + 1);\n                    // Show toast notification\n                    (0,sonner__WEBPACK_IMPORTED_MODULE_2__.toast)(newNotification.title, {\n                        description: newNotification.message,\n                        action: {\n                            label: \"Ver\",\n                            onClick: ()=>{\n                                // Handle notification click\n                                markAsRead(newNotification.id);\n                            }\n                        }\n                    });\n                } else if (data.type === \"feed_update\") {\n                    // Handle feed updates\n                    sonner__WEBPACK_IMPORTED_MODULE_2__.toast.info(\"Nueva actividad en tu feed\", {\n                        description: \"Hay nuevas publicaciones disponibles\"\n                    });\n                } else if (data.type === \"system_announcement\") {\n                    // Handle system announcements\n                    sonner__WEBPACK_IMPORTED_MODULE_2__.toast.warning(data.data.title, {\n                        description: data.data.message,\n                        duration: 10000 // Show for 10 seconds\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error parsing notification data:\", error);\n            }\n        };\n        es.onerror = (error)=>{\n            console.error(\"Notifications stream error:\", error);\n            setIsConnected(false);\n            // Attempt to reconnect after 5 seconds\n            setTimeout(()=>{\n                if (es.readyState === EventSource.CLOSED) {\n                    // Will trigger useEffect again\n                    setEventSource(null);\n                }\n            }, 5000);\n        };\n        setEventSource(es);\n        // Cleanup\n        return ()=>{\n            es.close();\n            setIsConnected(false);\n        };\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user3 = session.user) === null || _session_user3 === void 0 ? void 0 : _session_user3.id,\n        markAsRead\n    ]);\n    // Initial fetch of notifications\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchNotifications();\n    }, [\n        fetchNotifications\n    ]);\n    // Refresh notifications\n    const refreshNotifications = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        await fetchNotifications();\n    }, [\n        fetchNotifications\n    ]);\n    return {\n        notifications,\n        unreadCount,\n        isConnected,\n        markAsRead,\n        markAllAsRead,\n        refreshNotifications\n    };\n}\n// Hook for managing notification preferences\nfunction useNotificationPreferences() {\n    var _session_user, _session_user1;\n    const { data: session } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_1__.useSession)();\n    const [preferences, setPreferences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        email: true,\n        push: true,\n        social: true,\n        academic: true,\n        gamification: true,\n        marketplace: true,\n        system: true\n    });\n    // Fetch preferences\n    const fetchPreferences = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return;\n        try {\n            const response = await fetch(\"/api/notifications/preferences\");\n            if (response.ok) {\n                const data = await response.json();\n                setPreferences(data);\n            }\n        } catch (error) {\n            console.error(\"Error fetching notification preferences:\", error);\n        }\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id\n    ]);\n    // Update preferences\n    const updatePreferences = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (newPreferences)=>{\n        var _session_user;\n        if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) return;\n        try {\n            const response = await fetch(\"/api/notifications/preferences\", {\n                method: \"PATCH\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(newPreferences)\n            });\n            if (response.ok) {\n                setPreferences((prev)=>({\n                        ...prev,\n                        ...newPreferences\n                    }));\n                sonner__WEBPACK_IMPORTED_MODULE_2__.toast.success(\"Preferencias actualizadas\");\n            }\n        } catch (error) {\n            console.error(\"Error updating notification preferences:\", error);\n            sonner__WEBPACK_IMPORTED_MODULE_2__.toast.error(\"Error al actualizar preferencias\");\n        }\n    }, [\n        session === null || session === void 0 ? void 0 : (_session_user1 = session.user) === null || _session_user1 === void 0 ? void 0 : _session_user1.id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchPreferences();\n    }, [\n        fetchPreferences\n    ]);\n    return {\n        preferences,\n        updatePreferences\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3RpZmljYXRpb25zLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7aUdBRXlEO0FBQ1o7QUFDZDtBQXFCeEIsU0FBU0s7UUFxQlZDLGVBd0JBQSxnQkFvQkFBLGdCQWdGQUE7SUFoSkosTUFBTSxFQUFFQyxNQUFNRCxPQUFPLEVBQUUsR0FBR0gsMkRBQVVBO0lBQ3BDLE1BQU0sQ0FBQ0ssZUFBZUMsaUJBQWlCLEdBQUdULCtDQUFRQSxDQUFpQixFQUFFO0lBQ3JFLE1BQU0sQ0FBQ1UsYUFBYUMsZUFBZSxHQUFHWCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNZLGFBQWFDLGVBQWUsR0FBR2IsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDYyxhQUFhQyxlQUFlLEdBQUdmLCtDQUFRQSxDQUFxQjtJQUVuRSwrQkFBK0I7SUFDL0IsTUFBTWdCLHFCQUFxQmQsa0RBQVdBLENBQUM7WUFDaENJO1FBQUwsSUFBSSxFQUFDQSxvQkFBQUEsK0JBQUFBLGdCQUFBQSxRQUFTVyxJQUFJLGNBQWJYLG9DQUFBQSxjQUFlWSxFQUFFLEdBQUU7UUFFeEIsSUFBSTtZQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFBTTtZQUM3QixJQUFJRCxTQUFTRSxFQUFFLEVBQUU7Z0JBQ2YsTUFBTWQsT0FBTyxNQUFNWSxTQUFTRyxJQUFJO2dCQUNoQ2IsaUJBQWlCRixLQUFLQyxhQUFhLElBQUksRUFBRTtnQkFDekNHLGVBQWVKLEtBQUtHLFdBQVcsSUFBSTtZQUNyQztRQUNGLEVBQUUsT0FBT2EsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtRQUNqRDtJQUNGLEdBQUc7UUFBQ2pCLG9CQUFBQSwrQkFBQUEsZ0JBQUFBLFFBQVNXLElBQUksY0FBYlgsb0NBQUFBLGNBQWVZLEVBQUU7S0FBQztJQUV0Qiw0QkFBNEI7SUFDNUIsTUFBTU8sYUFBYXZCLGtEQUFXQSxDQUFDLE9BQU93QjtZQUMvQnBCO1FBQUwsSUFB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Q0FBQUEsT0FBUzt3QkFBRSxHQUFHQSxJQUFJO3dCQUFFLEdBQUc2QyxjQUFjO29CQUFDO2dCQUNyRHJFLHlDQUFLQSxDQUFDeUUsT0FBTyxDQUFDO1lBQ2hCO1FBQ0YsRUFBRSxPQUFPdEQsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNENBQTRDQTtZQUMxRG5CLHlDQUFLQSxDQUFDbUIsS0FBSyxDQUFDO1FBQ2Q7SUFDRixHQUFHO1FBQUNqQixvQkFBQUEsK0JBQUFBLGlCQUFBQSxRQUFTVyxJQUFJLGNBQWJYLHFDQUFBQSxlQUFlWSxFQUFFO0tBQUM7SUFFdEJqQixnREFBU0EsQ0FBQztRQUNSc0U7SUFDRixHQUFHO1FBQUNBO0tBQWlCO0lBRXJCLE9BQU87UUFDTFQ7UUFDQVU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VOb3RpZmljYXRpb25zLnRzPzkzNTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZVNlc3Npb24gfSBmcm9tICduZXh0LWF1dGgvcmVhY3QnO1xyXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gJ3Nvbm5lcic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvbiB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0eXBlOiAnU09DSUFMJyB8ICdBQ0FERU1JQycgfCAnR0FNSUZJQ0FUSU9OJyB8ICdNQVJLRVRQTEFDRScgfCAnU1lTVEVNJztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICBkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICByZWFkOiBib29sZWFuO1xyXG4gIGNyZWF0ZWRBdDogRGF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VOb3RpZmljYXRpb25zUmV0dXJuIHtcclxuICBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXTtcclxuICB1bnJlYWRDb3VudDogbnVtYmVyO1xyXG4gIGlzQ29ubmVjdGVkOiBib29sZWFuO1xyXG4gIG1hcmtBc1JlYWQ6IChub3RpZmljYXRpb25JZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIG1hcmtBbGxBc1JlYWQ6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgcmVmcmVzaE5vdGlmaWNhdGlvbnM6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VOb3RpZmljYXRpb25zKCk6IFVzZU5vdGlmaWNhdGlvbnNSZXR1cm4ge1xyXG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xyXG4gIGNvbnN0IFtub3RpZmljYXRpb25zLCBzZXROb3RpZmljYXRpb25zXSA9IHVzZVN0YXRlPE5vdGlmaWNhdGlvbltdPihbXSk7XHJcbiAgY29uc3QgW3VucmVhZENvdW50LCBzZXRVbnJlYWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbZXZlbnRTb3VyY2UsIHNldEV2ZW50U291cmNlXSA9IHVzZVN0YXRlPEV2ZW50U291cmNlIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIEZldGNoIG5vdGlmaWNhdGlvbnMgZnJvbSBBUElcclxuICBjb25zdCBmZXRjaE5vdGlmaWNhdGlvbnMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoIXNlc3Npb24/LnVzZXI/LmlkKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zJyk7XHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgc2V0Tm90aWZpY2F0aW9ucyhkYXRhLm5vdGlmaWNhdGlvbnMgfHwgW10pO1xyXG4gICAgICAgIHNldFVucmVhZENvdW50KGRhdGEudW5yZWFkQ291bnQgfHwgMCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG5vdGlmaWNhdGlvbnM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sIFtzZXNzaW9uPy51c2VyPy5pZF0pO1xyXG5cclxuICAvLyBNYXJrIG5vdGlmaWNhdGlvbiBhcyByZWFkXHJcbiAgY29uc3QgbWFya0FzUmVhZCA9IHVzZUNhbGxiYWNrKGFzeW5jIChub3RpZmljYXRpb25JZDogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAoIXNlc3Npb24/LnVzZXI/LmlkKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9ub3RpZmljYXRpb25zLyR7bm90aWZpY2F0aW9uSWR9L3JlYWRgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgc2V0Tm90aWZpY2F0aW9ucyhwcmV2ID0+IFxyXG4gICAgICAgICAgcHJldi5tYXAobm90aWZpY2F0aW9uID0+IFxyXG4gICAgICAgICAgICBub3RpZmljYXRpb24uaWQgPT09IG5vdGlmaWNhdGlvbklkIFxyXG4gICAgICAgICAgICAgID8geyAuLi5ub3RpZmljYXRpb24sIHJlYWQ6IHRydWUgfVxyXG4gICAgICAgICAgICAgIDogbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzZXRVbnJlYWRDb3VudChwcmV2ID0+IE1hdGgubWF4KDAsIHByZXYgLSAxKSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1hcmtpbmcgbm90aWZpY2F0aW9uIGFzIHJlYWQ6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sIFtzZXNzaW9uPy51c2VyPy5pZF0pO1xyXG5cclxuICAvLyBNYXJrIGFsbCBub3RpZmljYXRpb25zIGFzIHJlYWRcclxuICBjb25zdCBtYXJrQWxsQXNSZWFkID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFzZXNzaW9uPy51c2VyPy5pZCkgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvbm90aWZpY2F0aW9ucy9yZWFkLWFsbCcsIHtcclxuICAgICAgICBtZXRob2Q6ICdQQVRDSCdcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBzZXROb3RpZmljYXRpb25zKHByZXYgPT4gXHJcbiAgICAgICAgICBwcmV2Lm1hcChub3RpZmljYXRpb24gPT4gKHsgLi4ubm90aWZpY2F0aW9uLCByZWFkOiB0cnVlIH0pKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2V0VW5yZWFkQ291bnQoMCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1hcmtpbmcgYWxsIG5vdGlmaWNhdGlvbnMgYXMgcmVhZDonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfSwgW3Nlc3Npb24/LnVzZXI/LmlkXSk7XHJcblxyXG4gIC8vIFNldHVwIFNlcnZlci1TZW50IEV2ZW50cyBmb3IgcmVhbC10aW1lIG5vdGlmaWNhdGlvbnNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFzZXNzaW9uPy51c2VyPy5pZCkge1xyXG4gICAgICBpZiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xyXG4gICAgICAgIHNldEV2ZW50U291cmNlKG51bGwpO1xyXG4gICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIEV2ZW50U291cmNlIGZvciByZWFsLXRpbWUgbm90aWZpY2F0aW9uc1xyXG4gICAgY29uc3QgZXMgPSBuZXcgRXZlbnRTb3VyY2UoYC9hcGkvbm90aWZpY2F0aW9ucy9zdHJlYW0/dXNlcklkPSR7c2Vzc2lvbi51c2VyLmlkfWApO1xyXG4gICAgXHJcbiAgICBlcy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xyXG4gICAgICBjb25zb2xlLmxvZygnTm90aWZpY2F0aW9ucyBzdHJlYW0gY29ubmVjdGVkJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGVzLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdub3RpZmljYXRpb24nKSB7XHJcbiAgICAgICAgICBjb25zdCBuZXdOb3RpZmljYXRpb24gPSBkYXRhLmRhdGE7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFkZCB0byBub3RpZmljYXRpb25zIGxpc3RcclxuICAgICAgICAgIHNldE5vdGlmaWNhdGlvbnMocHJldiA9PiBbbmV3Tm90aWZpY2F0aW9uLCAuLi5wcmV2LnNsaWNlKDAsIDQ5KV0pOyAvLyBLZWVwIG9ubHkgNTAgbm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAgc2V0VW5yZWFkQ291bnQocHJldiA9PiBwcmV2ICsgMSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFNob3cgdG9hc3Qgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgICB0b2FzdChuZXdOb3RpZmljYXRpb24udGl0bGUsIHtcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG5ld05vdGlmaWNhdGlvbi5tZXNzYWdlLFxyXG4gICAgICAgICAgICBhY3Rpb246IHtcclxuICAgICAgICAgICAgICBsYWJlbDogJ1ZlcicsXHJcbiAgICAgICAgICAgICAgb25DbGljazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIG5vdGlmaWNhdGlvbiBjbGlja1xyXG4gICAgICAgICAgICAgICAgbWFya0FzUmVhZChuZXdOb3RpZmljYXRpb24uaWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdmZWVkX3VwZGF0ZScpIHtcclxuICAgICAgICAgIC8vIEhhbmRsZSBmZWVkIHVwZGF0ZXNcclxuICAgICAgICAgIHRvYXN0LmluZm8oJ051ZXZhIGFjdGl2aWRhZCBlbiB0dSBmZWVkJywge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0hheSBudWV2YXMgcHVibGljYWNpb25lcyBkaXNwb25pYmxlcydcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnc3lzdGVtX2Fubm91bmNlbWVudCcpIHtcclxuICAgICAgICAgIC8vIEhhbmRsZSBzeXN0ZW0gYW5ub3VuY2VtZW50c1xyXG4gICAgICAgICAgdG9hc3Qud2FybmluZyhkYXRhLmRhdGEudGl0bGUsIHtcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuZGF0YS5tZXNzYWdlLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAwMDAgLy8gU2hvdyBmb3IgMTAgc2Vjb25kc1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgbm90aWZpY2F0aW9uIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGVzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcignTm90aWZpY2F0aW9ucyBzdHJlYW0gZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBBdHRlbXB0IHRvIHJlY29ubmVjdCBhZnRlciA1IHNlY29uZHNcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVzLnJlYWR5U3RhdGUgPT09IEV2ZW50U291cmNlLkNMT1NFRCkge1xyXG4gICAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIHVzZUVmZmVjdCBhZ2FpblxyXG4gICAgICAgICAgc2V0RXZlbnRTb3VyY2UobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCA1MDAwKTtcclxuICAgIH07XHJcblxyXG4gICAgc2V0RXZlbnRTb3VyY2UoZXMpO1xyXG5cclxuICAgIC8vIENsZWFudXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGVzLmNsb3NlKCk7XHJcbiAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcclxuICAgIH07XHJcbiAgfSwgW3Nlc3Npb24/LnVzZXI/LmlkLCBtYXJrQXNSZWFkXSk7XHJcblxyXG4gIC8vIEluaXRpYWwgZmV0Y2ggb2Ygbm90aWZpY2F0aW9uc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBmZXRjaE5vdGlmaWNhdGlvbnMoKTtcclxuICB9LCBbZmV0Y2hOb3RpZmljYXRpb25zXSk7XHJcblxyXG4gIC8vIFJlZnJlc2ggbm90aWZpY2F0aW9uc1xyXG4gIGNvbnN0IHJlZnJlc2hOb3RpZmljYXRpb25zID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgYXdhaXQgZmV0Y2hOb3RpZmljYXRpb25zKCk7XHJcbiAgfSwgW2ZldGNoTm90aWZpY2F0aW9uc10pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbm90aWZpY2F0aW9ucyxcclxuICAgIHVucmVhZENvdW50LFxyXG4gICAgaXNDb25uZWN0ZWQsXHJcbiAgICBtYXJrQXNSZWFkLFxyXG4gICAgbWFya0FsbEFzUmVhZCxcclxuICAgIHJlZnJlc2hOb3RpZmljYXRpb25zXHJcbiAgfTtcclxufVxyXG5cclxuLy8gSG9vayBmb3IgbWFuYWdpbmcgbm90aWZpY2F0aW9uIHByZWZlcmVuY2VzXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VOb3RpZmljYXRpb25QcmVmZXJlbmNlcygpIHtcclxuICBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcclxuICBjb25zdCBbcHJlZmVyZW5jZXMsIHNldFByZWZlcmVuY2VzXSA9IHVzZVN0YXRlKHtcclxuICAgIGVtYWlsOiB0cnVlLFxyXG4gICAgcHVzaDogdHJ1ZSxcclxuICAgIHNvY2lhbDogdHJ1ZSxcclxuICAgIGFjYWRlbWljOiB0cnVlLFxyXG4gICAgZ2FtaWZpY2F0aW9uOiB0cnVlLFxyXG4gICAgbWFya2V0cGxhY2U6IHRydWUsXHJcbiAgICBzeXN0ZW06IHRydWVcclxuICB9KTtcclxuXHJcbiAgLy8gRmV0Y2ggcHJlZmVyZW5jZXNcclxuICBjb25zdCBmZXRjaFByZWZlcmVuY2VzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCFzZXNzaW9uPy51c2VyPy5pZCkgcmV0dXJuO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvbm90aWZpY2F0aW9ucy9wcmVmZXJlbmNlcycpO1xyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHNldFByZWZlcmVuY2VzKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBub3RpZmljYXRpb24gcHJlZmVyZW5jZXM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH0sIFtzZXNzaW9uPy51c2VyPy5pZF0pO1xyXG5cclxuICAvLyBVcGRhdGUgcHJlZmVyZW5jZXNcclxuICBjb25zdCB1cGRhdGVQcmVmZXJlbmNlcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdQcmVmZXJlbmNlczogUGFydGlhbDx0eXBlb2YgcHJlZmVyZW5jZXM+KSA9PiB7XHJcbiAgICBpZiAoIXNlc3Npb24/LnVzZXI/LmlkKSByZXR1cm47XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zL3ByZWZlcmVuY2VzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShuZXdQcmVmZXJlbmNlcylcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICBzZXRQcmVmZXJlbmNlcyhwcmV2ID0+ICh7IC4uLnByZXYsIC4uLm5ld1ByZWZlcmVuY2VzIH0pKTtcclxuICAgICAgICB0b2FzdC5zdWNjZXNzKCdQcmVmZXJlbmNpYXMgYWN0dWFsaXphZGFzJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIG5vdGlmaWNhdGlvbiBwcmVmZXJlbmNlczonLCBlcnJvcik7XHJcbiAgICAgIHRvYXN0LmVycm9yKCdFcnJvciBhbCBhY3R1YWxpemFyIHByZWZlcmVuY2lhcycpO1xyXG4gICAgfVxyXG4gIH0sIFtzZXNzaW9uPy51c2VyPy5pZF0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hQcmVmZXJlbmNlcygpO1xyXG4gIH0sIFtmZXRjaFByZWZlcmVuY2VzXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBwcmVmZXJlbmNlcyxcclxuICAgIHVwZGF0ZVByZWZlcmVuY2VzXHJcbiAgfTtcclxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlU2Vzc2lvbiIsInRvYXN0IiwidXNlTm90aWZpY2F0aW9ucyIsInNlc3Npb24iLCJkYXRhIiwibm90aWZpY2F0aW9ucyIsInNldE5vdGlmaWNhdGlvbnMiLCJ1bnJlYWRDb3VudCIsInNldFVucmVhZENvdW50IiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImV2ZW50U291cmNlIiwic2V0RXZlbnRTb3VyY2UiLCJmZXRjaE5vdGlmaWNhdGlvbnMiLCJ1c2VyIiwiaWQiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwibWFya0FzUmVhZCIsIm5vdGlmaWNhdGlvbklkIiwibWV0aG9kIiwicHJldiIsIm1hcCIsIm5vdGlmaWNhdGlvbiIsInJlYWQiLCJNYXRoIiwibWF4IiwibWFya0FsbEFzUmVhZCIsImNsb3NlIiwiZXMiLCJFdmVudFNvdXJjZSIsIm9ub3BlbiIsImxvZyIsIm9ubWVzc2FnZSIsImV2ZW50IiwiSlNPTiIsInBhcnNlIiwidHlwZSIsIm5ld05vdGlmaWNhdGlvbiIsInNsaWNlIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsIm1lc3NhZ2UiLCJhY3Rpb24iLCJsYWJlbCIsIm9uQ2xpY2siLCJpbmZvIiwid2FybmluZyIsImR1cmF0aW9uIiwib25lcnJvciIsInNldFRpbWVvdXQiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwicmVmcmVzaE5vdGlmaWNhdGlvbnMiLCJ1c2VOb3RpZmljYXRpb25QcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzIiwic2V0UHJlZmVyZW5jZXMiLCJlbWFpbCIsInB1c2giLCJzb2NpYWwiLCJhY2FkZW1pYyIsImdhbWlmaWNhdGlvbiIsIm1hcmtldHBsYWNlIiwic3lzdGVtIiwiZmV0Y2hQcmVmZXJlbmNlcyIsInVwZGF0ZVByZWZlcmVuY2VzIiwibmV3UHJlZmVyZW5jZXMiLCJoZWFkZXJzIiwiYm9keSIsInN0cmluZ2lmeSIsInN1Y2Nlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNotifications.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/notificationService.ts":
/*!*********************************************!*\
  !*** ./src/services/notificationService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notificationService: function() { return /* binding */ notificationService; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_define_property.js\");\n/* harmony import */ var _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hooks/useNotifications */ \"(app-pages-browser)/./src/hooks/useNotifications.ts\");\n\n\nclass NotificationService {\n    async initializeSSE() {\n        try {\n            // Conectar a Server-Sent Events\n            this.eventSource = new EventSource(\"/api/notifications/stream\");\n            this.eventSource.onopen = ()=>{\n                console.log(\"Connected to notification stream\");\n                this.isConnected = true;\n            };\n            this.eventSource.onmessage = (event)=>{\n                try {\n                    const data = JSON.parse(event.data);\n                    if (data.type === \"notification\") {\n                        this.handleNewNotification(data.data);\n                    } else if (data.type === \"connected\") {\n                        console.log(\"SSE connection established\");\n                    }\n                } catch (error) {\n                    console.error(\"Error parsing SSE message:\", error);\n                }\n            };\n            this.eventSource.onerror = (error)=>{\n                console.error(\"SSE connection error:\", error);\n                this.isConnected = false;\n                // Intentar reconectar después de 5 segundos\n                setTimeout(()=>{\n                    var _this_eventSource;\n                    if (((_this_eventSource = this.eventSource) === null || _this_eventSource === void 0 ? void 0 : _this_eventSource.readyState) === EventSource.CLOSED) {\n                        this.initializeSSE();\n                    }\n                }, 5000);\n            };\n        } catch (error) {\n            console.warn(\"SSE not available:\", error);\n            this.isConnected = false;\n        }\n    }\n    async connect() {\n        if (!this.isConnected) {\n            await this.initializeSSE();\n            // Cargar notificaciones existentes\n            await this.loadNotifications();\n        }\n    }\n    disconnect() {\n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n            this.isConnected = false;\n        }\n    }\n    // Cargar notificaciones desde la API\n    async loadNotifications() {\n        try {\n            const response = await fetch(\"/api/notifications\");\n            if (response.ok) {\n                const data = await response.json();\n                this.notifications = data.notifications.map((n)=>({\n                        ...n,\n                        createdAt: new Date(n.createdAt)\n                    }));\n            }\n        } catch (error) {\n            console.error(\"Error loading notifications:\", error);\n        }\n    }\n    handleNewNotification(notification) {\n        // Agregar la notificación a la lista\n        this.notifications.unshift(notification);\n        // Mantener solo las últimas 100 notificaciones\n        if (this.notifications.length > 100) {\n            this.notifications = this.notifications.slice(0, 100);\n        }\n        // Notificar a todos los listeners\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(notification);\n            } catch (error) {\n                console.error(\"Error in notification listener:\", error);\n            }\n        });\n        // Mostrar notificación del navegador si está permitido\n        this.showBrowserNotification(notification);\n    }\n    showBrowserNotification(notification) {\n        if (\"Notification\" in window && _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__.Notification.permission === \"granted\") {\n            const browserNotification = new _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__.Notification(notification.title, {\n                body: notification.message,\n                icon: \"/favicon.ico\",\n                tag: notification.id\n            });\n            // Auto-cerrar después de 5 segundos\n            setTimeout(()=>{\n                browserNotification.close();\n            }, 5000);\n        }\n    }\n    // Método para simular notificaciones cuando WebSocket no está disponible\n    simulateNotification(notification) {\n        const fullNotification = {\n            ...notification,\n            id: Math.random().toString(36).substr(2, 9),\n            timestamp: new Date(),\n            read: false\n        };\n        this.handleNewNotification(fullNotification);\n    }\n    // Suscribirse a notificaciones\n    subscribe(listener) {\n        this.listeners.push(listener);\n        // Retornar función para desuscribirse\n        return ()=>{\n            const index = this.listeners.indexOf(listener);\n            if (index > -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n    }\n    // Obtener todas las notificaciones\n    getNotifications() {\n        return [\n            ...this.notifications\n        ];\n    }\n    // Obtener notificaciones no leídas\n    getUnreadNotifications() {\n        return this.notifications.filter((n)=>!n.read);\n    }\n    // Marcar notificación como leída\n    async markAsRead(notificationId) {\n        try {\n            const response = await fetch(\"/api/notifications/\".concat(notificationId, \"/read\"), {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                const notification = this.notifications.find((n)=>n.id === notificationId);\n                if (notification) {\n                    notification.read = true;\n                }\n            }\n        } catch (error) {\n            console.error(\"Error marking notification as read:\", error);\n        }\n    }\n    // Marcar todas como leídas\n    async markAllAsRead() {\n        try {\n            const response = await fetch(\"/api/notifications/read-all\", {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                this.notifications.forEach((n)=>n.read = true);\n            }\n        } catch (error) {\n            console.error(\"Error marking all notifications as read:\", error);\n        }\n    }\n    // Eliminar notificación\n    removeNotification(notificationId) {\n        const index = this.notifications.findIndex((n)=>n.id === notificationId);\n        if (index > -1) {\n            this.notifications.splice(index, 1);\n        }\n    }\n    // Limpiar todas las notificaciones\n    clearAll() {\n        this.notifications = [];\n    }\n    // Solicitar permisos para notificaciones del navegador\n    async requestNotificationPermission() {\n        if (\"Notification\" in window) {\n            const permission = await _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__.Notification.requestPermission();\n            return permission;\n        }\n        return \"denied\";\n    }\n    // Obtener estado de conexión\n    getConnectionStatus() {\n        return this.isConnected;\n    }\n    // Crear notificación en el servidor\n    async createNotification(type, title, message, data) {\n        try {\n            const response = await fetch(\"/api/notifications\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    type,\n                    title,\n                    message,\n                    data\n                })\n            });\n            if (response.ok) {\n                const notification = await response.json();\n                return notification;\n            }\n        } catch (error) {\n            console.error(\"Error creating notification:\", error);\n        }\n    }\n    // Enviar notificación de XP ganado\n    async notifyXPGained(xp, reason) {\n        await this.createNotification(\"CROLARS_EARNED\", \"\\xa1XP Ganado!\", \"Has ganado \".concat(xp, \" XP por \").concat(reason), {\n            xp,\n            reason\n        });\n    }\n    // Enviar notificación de subida de nivel\n    async notifyLevelUp(newLevel) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Nivel Alcanzado!\", \"\\xa1Felicidades! Has alcanzado el nivel \".concat(newLevel), {\n            level: newLevel\n        });\n    }\n    // Enviar notificación de badge ganado\n    async notifyBadgeEarned(badgeName) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Badge Desbloqueado!\", \"Has desbloqueado el badge: \".concat(badgeName), {\n            badge: badgeName\n        });\n    }\n    constructor(){\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"eventSource\", null);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"listeners\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"notifications\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"isConnected\", false);\n    // No inicializar automáticamente, esperar a que el usuario se conecte\n    }\n}\n// Instancia singleton\nconst notificationService = new NotificationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9ub3RpZmljYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUQ7QUFNekQsTUFBTUM7SUFVSixNQUFjQyxnQkFBZ0I7UUFDNUIsSUFBSTtZQUNGLGdDQUFnQztZQUNoQyxJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJQyxZQUFZO1lBRW5DLElBQUksQ0FBQ0QsV0FBVyxDQUFDRSxNQUFNLEdBQUc7Z0JBQ3hCQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFDckI7WUFFQSxJQUFJLENBQUNMLFdBQVcsQ0FBQ00sU0FBUyxHQUFHLENBQUNDO2dCQUM1QixJQUFJO29CQUNGLE1BQU1DLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUMsSUFBSTtvQkFFbEMsSUFBSUEsS0FBS0csSUFBSSxLQUFLLGdCQUFnQjt3QkFDaEMsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0osS0FBS0EsSUFBSTtvQkFDdEMsT0FBTyxJQUFJQSxLQUFLRyxJQUFJLEtBQUssYUFBYTt3QkFDcENSLFFBQVFDLEdBQUcsQ0FBQztvQkFDZDtnQkFDRixFQUFFLE9BQU9TLE9BQU87b0JBQ2RWLFFBQVFVLEtBQUssQ0FBQyw4QkFBOEJBO2dCQUM5QztZQUNGO1lBRUEsSUFBSSxDQUFDYixXQUFXLENBQUNjLE9BQU8sR0FBRyxDQUFDRDtnQkFDMUJWLFFBQVFVLEtBQUssQ0FBQyx5QkFBeUJBO2dCQUN2QyxJQUFJLENBQUNSLFdBQVcsR0FBRztnQkFFbkIsNENBQTRDO2dCQUM1Q1UsV0FBVzt3QkFDTDtvQkFBSixJQUFJLDBCQUFJLENBQUNmLFdBQVcsY0FBaEIsMERBQWtCZ0IsVUFBVSxNQUFLZixZQUFZZ0IsTUFBTSxFQUFFO3dCQUN2RCxJQUFJLENBQUNsQixhQUFhO29CQUNwQjtnQkFDRixHQUFHO1lBQ0w7UUFFRixFQUFFLE9BQU9jLE9BQU87WUFDZFYsUUFBUWUsSUFBSSxDQUFD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RUFBRTtRQUNwQyxNQUFNLElBQUksQ0FBQ1Asa0JBQWtCLENBQzNCLFVBQ0Esd0JBQ0EsMkNBQWlELE9BQVRPLFdBQ3hDO1lBQUVDLE9BQU9EO1FBQVM7SUFFdEI7SUFFQSxzQ0FBc0M7SUFDdEMsTUFBTUUsa0JBQWtCQyxTQUFpQixFQUFFO1FBQ3pDLE1BQU0sSUFBSSxDQUFDVixrQkFBa0IsQ0FDM0IsVUFDQSwyQkFDQSw4QkFBd0MsT0FBVlUsWUFDOUI7WUFBRUMsT0FBT0Q7UUFBVTtJQUV2QjtJQXZRQUUsYUFBYztRQUxkLHNFQUFReEYsZUFBa0M7UUFDMUMsc0VBQVFvQyxhQUFvQyxFQUFFO1FBQzlDLHNFQUFRVCxpQkFBZ0MsRUFBRTtRQUMxQyxzRUFBUXRCLGVBQWM7SUFHcEIsc0VBQXNFO0lBQ3hFO0FBd1FGO0FBRUEsc0JBQXNCO0FBQ2YsTUFBTW9GLHNCQUFzQixJQUFJM0Ysc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9ub3RpZmljYXRpb25TZXJ2aWNlLnRzP2YxODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlTm90aWZpY2F0aW9ucyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uTGlzdGVuZXIge1xuICAobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pOiB2b2lkO1xufVxuXG5jbGFzcyBOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBldmVudFNvdXJjZTogRXZlbnRTb3VyY2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE5vdGlmaWNhdGlvbkxpc3RlbmVyW10gPSBbXTtcbiAgcHJpdmF0ZSBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXSA9IFtdO1xuICBwcml2YXRlIGlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gTm8gaW5pY2lhbGl6YXIgYXV0b23DoXRpY2FtZW50ZSwgZXNwZXJhciBhIHF1ZSBlbCB1c3VhcmlvIHNlIGNvbmVjdGVcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVNTRSgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uZWN0YXIgYSBTZXJ2ZXItU2VudCBFdmVudHNcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9hcGkvbm90aWZpY2F0aW9ucy9zdHJlYW0nKTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gbm90aWZpY2F0aW9uIHN0cmVhbScpO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ25vdGlmaWNhdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTmV3Tm90aWZpY2F0aW9uKGRhdGEuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU1NFIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBTU0UgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTU0UgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIEludGVudGFyIHJlY29uZWN0YXIgZGVzcHXDqXMgZGUgNSBzZWd1bmRvc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudFNvdXJjZT8ucmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTU0UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMDApO1xuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NTRSBub3QgYXZhaWxhYmxlOicsIGVycm9yKTtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplU1NFKCk7XG4gICAgICAvLyBDYXJnYXIgbm90aWZpY2FjaW9uZXMgZXhpc3RlbnRlc1xuICAgICAgYXdhaXQgdGhpcy5sb2FkTm90aWZpY2F0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhcmdhciBub3RpZmljYWNpb25lcyBkZXNkZSBsYSBBUElcbiAgcHJpdmF0ZSBhc3luYyBsb2FkTm90aWZpY2F0aW9ucygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zJyk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gZGF0YS5ub3RpZmljYXRpb25zLm1hcCgobjogYW55KSA9PiAoe1xuICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShuLmNyZWF0ZWRBdClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG5vdGlmaWNhdGlvbnM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTmV3Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uKSB7XG4gICAgLy8gQWdyZWdhciBsYSBub3RpZmljYWNpw7NuIGEgbGEgbGlzdGFcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb24pO1xuICAgIFxuICAgIC8vIE1hbnRlbmVyIHNvbG8gbGFzIMO6bHRpbWFzIDEwMCBub3RpZmljYWNpb25lc1xuICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSB0aGlzLm5vdGlmaWNhdGlvbnMuc2xpY2UoMCwgMTAwKTtcbiAgICB9XG5cbiAgICAvLyBOb3RpZmljYXIgYSB0b2RvcyBsb3MgbGlzdGVuZXJzXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcihub3RpZmljYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbm90aWZpY2F0aW9uIGxpc3RlbmVyOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1vc3RyYXIgbm90aWZpY2FjacOzbiBkZWwgbmF2ZWdhZG9yIHNpIGVzdMOhIHBlcm1pdGlkb1xuICAgIHRoaXMuc2hvd0Jyb3dzZXJOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvd0Jyb3dzZXJOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pIHtcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXJOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbi50aXRsZSwge1xuICAgICAgICBib2R5OiBub3RpZmljYXRpb24ubWVzc2FnZSxcbiAgICAgICAgaWNvbjogJy9mYXZpY29uLmljbycsXG4gICAgICAgIHRhZzogbm90aWZpY2F0aW9uLmlkXG4gICAgICB9KTtcblxuICAgICAgLy8gQXV0by1jZXJyYXIgZGVzcHXDqXMgZGUgNSBzZWd1bmRvc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJyb3dzZXJOb3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIE3DqXRvZG8gcGFyYSBzaW11bGFyIG5vdGlmaWNhY2lvbmVzIGN1YW5kbyBXZWJTb2NrZXQgbm8gZXN0w6EgZGlzcG9uaWJsZVxuICBzaW11bGF0ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE9taXQ8Tm90aWZpY2F0aW9uLCAnaWQnIHwgJ3RpbWVzdGFtcCcgfCAncmVhZCc+KSB7XG4gICAgY29uc3QgZnVsbE5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uID0ge1xuICAgICAgLi4ubm90aWZpY2F0aW9uLFxuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIHJlYWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlTmV3Tm90aWZpY2F0aW9uKGZ1bGxOb3RpZmljYXRpb24pO1xuICB9XG5cbiAgLy8gU3VzY3JpYmlyc2UgYSBub3RpZmljYWNpb25lc1xuICBzdWJzY3JpYmUobGlzdGVuZXI6IE5vdGlmaWNhdGlvbkxpc3RlbmVyKTogKCkgPT4gdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgXG4gICAgLy8gUmV0b3JuYXIgZnVuY2nDs24gcGFyYSBkZXN1c2NyaWJpcnNlXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBPYnRlbmVyIHRvZGFzIGxhcyBub3RpZmljYWNpb25lc1xuICBnZXROb3RpZmljYXRpb25zKCk6IE5vdGlmaWNhdGlvbltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubm90aWZpY2F0aW9uc107XG4gIH1cblxuICAvLyBPYnRlbmVyIG5vdGlmaWNhY2lvbmVzIG5vIGxlw61kYXNcbiAgZ2V0VW5yZWFkTm90aWZpY2F0aW9ucygpOiBOb3RpZmljYXRpb25bXSB7XG4gICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9ucy5maWx0ZXIobiA9PiAhbi5yZWFkKTtcbiAgfVxuXG4gIC8vIE1hcmNhciBub3RpZmljYWNpw7NuIGNvbW8gbGXDrWRhXG4gIGFzeW5jIG1hcmtBc1JlYWQobm90aWZpY2F0aW9uSWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL25vdGlmaWNhdGlvbnMvJHtub3RpZmljYXRpb25JZH0vcmVhZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHRoaXMubm90aWZpY2F0aW9ucy5maW5kKG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLnJlYWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1hcmtpbmcgbm90aWZpY2F0aW9uIGFzIHJlYWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1hcmNhciB0b2RhcyBjb21vIGxlw61kYXNcbiAgYXN5bmMgbWFya0FsbEFzUmVhZCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zL3JlYWQtYWxsJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmZvckVhY2gobiA9PiBuLnJlYWQgPSB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFya2luZyBhbGwgbm90aWZpY2F0aW9ucyBhcyByZWFkOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbGltaW5hciBub3RpZmljYWNpw7NuXG4gIHJlbW92ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JZDogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm5vdGlmaWNhdGlvbnMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaW1waWFyIHRvZGFzIGxhcyBub3RpZmljYWNpb25lc1xuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBbXTtcbiAgfVxuXG4gIC8vIFNvbGljaXRhciBwZXJtaXNvcyBwYXJhIG5vdGlmaWNhY2lvbmVzIGRlbCBuYXZlZ2Fkb3JcbiAgYXN5bmMgcmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24oKTogUHJvbWlzZTxOb3RpZmljYXRpb25QZXJtaXNzaW9uPiB7XG4gICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdykge1xuICAgICAgY29uc3QgcGVybWlzc2lvbiA9IGF3YWl0IE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgICAgcmV0dXJuIHBlcm1pc3Npb247XG4gICAgfVxuICAgIHJldHVybiAnZGVuaWVkJztcbiAgfVxuXG4gIC8vIE9idGVuZXIgZXN0YWRvIGRlIGNvbmV4acOzblxuICBnZXRDb25uZWN0aW9uU3RhdHVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xuICB9XG5cbiAgLy8gQ3JlYXIgbm90aWZpY2FjacOzbiBlbiBlbCBzZXJ2aWRvclxuICBhc3luYyBjcmVhdGVOb3RpZmljYXRpb24odHlwZTogTm90aWZpY2F0aW9uWyd0eXBlJ10sIHRpdGxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL25vdGlmaWNhdGlvbnMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBub3RpZmljYXRpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVudmlhciBub3RpZmljYWNpw7NuIGRlIFhQIGdhbmFkb1xuICBhc3luYyBub3RpZnlYUEdhaW5lZCh4cDogbnVtYmVyLCByZWFzb246IHN0cmluZykge1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKFxuICAgICAgJ0NST0xBUlNfRUFSTkVEJyxcbiAgICAgICfCoVhQIEdhbmFkbyEnLFxuICAgICAgYEhhcyBnYW5hZG8gJHt4cH0gWFAgcG9yICR7cmVhc29ufWAsXG4gICAgICB7IHhwLCByZWFzb24gfVxuICAgICk7XG4gIH1cblxuICAvLyBFbnZpYXIgbm90aWZpY2FjacOzbiBkZSBzdWJpZGEgZGUgbml2ZWxcbiAgYXN5bmMgbm90aWZ5TGV2ZWxVcChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgYXdhaXQgdGhpcy5jcmVhdGVOb3RpZmljYXRpb24oXG4gICAgICAnU1lTVEVNJyxcbiAgICAgICfCoU5pdmVsIEFsY2FuemFkbyEnLFxuICAgICAgYMKhRmVsaWNpZGFkZXMhIEhhcyBhbGNhbnphZG8gZWwgbml2ZWwgJHtuZXdMZXZlbH1gLFxuICAgICAgeyBsZXZlbDogbmV3TGV2ZWwgfVxuICAgICk7XG4gIH1cblxuICAvLyBFbnZpYXIgbm90aWZpY2FjacOzbiBkZSBiYWRnZSBnYW5hZG9cbiAgYXN5bmMgbm90aWZ5QmFkZ2VFYXJuZWQoYmFkZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZU5vdGlmaWNhdGlvbihcbiAgICAgICdTWVNURU0nLFxuICAgICAgJ8KhQmFkZ2UgRGVzYmxvcXVlYWRvIScsXG4gICAgICBgSGFzIGRlc2Jsb3F1ZWFkbyBlbCBiYWRnZTogJHtiYWRnZU5hbWV9YCxcbiAgICAgIHsgYmFkZ2U6IGJhZGdlTmFtZSB9XG4gICAgKTtcbiAgfVxuXG5cbn1cblxuLy8gSW5zdGFuY2lhIHNpbmdsZXRvblxuZXhwb3J0IGNvbnN0IG5vdGlmaWNhdGlvblNlcnZpY2UgPSBuZXcgTm90aWZpY2F0aW9uU2VydmljZSgpOyJdLCJuYW1lcyI6WyJOb3RpZmljYXRpb24iLCJOb3RpZmljYXRpb25TZXJ2aWNlIiwiaW5pdGlhbGl6ZVNTRSIsImV2ZW50U291cmNlIiwiRXZlbnRTb3VyY2UiLCJvbm9wZW4iLCJjb25zb2xlIiwibG9nIiwiaXNDb25uZWN0ZWQiLCJvbm1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJ0eXBlIiwiaGFuZGxlTmV3Tm90aWZpY2F0aW9uIiwiZXJyb3IiLCJvbmVycm9yIiwic2V0VGltZW91dCIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJ3YXJuIiwiY29ubmVjdCIsImxvYWROb3RpZmljYXRpb25zIiwiZGlzY29ubmVjdCIsImNsb3NlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwianNvbiIsIm5vdGlmaWNhdGlvbnMiLCJtYXAiLCJuIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIm5vdGlmaWNhdGlvbiIsInVuc2hpZnQiLCJsZW5ndGgiLCJzbGljZSIsImxpc3RlbmVycyIsImZvckVhY2giLCJsaXN0ZW5lciIsInNob3dCcm93c2VyTm90aWZpY2F0aW9uIiwid2luZG93IiwicGVybWlzc2lvbiIsImJyb3dzZXJOb3RpZmljYXRpb24iLCJ0aXRsZSIsImJvZHkiLCJtZXNzYWdlIiwiaWNvbiIsInRhZyIsImlkIiwic2ltdWxhdGVOb3RpZmljYXRpb24iLCJmdWxsTm90aWZpY2F0aW9uIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidGltZXN0YW1wIiwicmVhZCIsInN1YnNjcmliZSIsInB1c2giLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJnZXROb3RpZmljYXRpb25zIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9ucyIsImZpbHRlciIsIm1hcmtBc1JlYWQiLCJub3RpZmljYXRpb25JZCIsIm1ldGhvZCIsImZpbmQiLCJtYXJrQWxsQXNSZWFkIiwicmVtb3ZlTm90aWZpY2F0aW9uIiwiZmluZEluZGV4IiwiY2xlYXJBbGwiLCJyZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbiIsInJlcXVlc3RQZXJtaXNzaW9uIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsImNyZWF0ZU5vdGlmaWNhdGlvbiIsImhlYWRlcnMiLCJzdHJpbmdpZnkiLCJub3RpZnlYUEdhaW5lZCIsInhwIiwicmVhc29uIiwibm90aWZ5TGV2ZWxVcCIsIm5ld0xldmVsIiwibGV2ZWwiLCJub3RpZnlCYWRnZUVhcm5lZCIsImJhZGdlTmFtZSIsImJhZGdlIiwiY29uc3RydWN0b3IiLCJub3RpZmljYXRpb25TZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/notificationService.ts\n"));

/***/ })

});