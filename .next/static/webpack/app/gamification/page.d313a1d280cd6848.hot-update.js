"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gamification/page",{

/***/ "(app-pages-browser)/./src/services/notificationService.ts":
/*!*********************************************!*\
  !*** ./src/services/notificationService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notificationService: function() { return /* binding */ notificationService; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_define_property.js\");\n\nclass NotificationService {\n    async initializeSSE() {\n        try {\n            // Conectar a Server-Sent Events\n            this.eventSource = new EventSource(\"/api/notifications/stream\");\n            this.eventSource.onopen = ()=>{\n                console.log(\"Connected to notification stream\");\n                this.isConnected = true;\n            };\n            this.eventSource.onmessage = (event)=>{\n                try {\n                    const data = JSON.parse(event.data);\n                    if (data.type === \"notification\") {\n                        this.handleNewNotification(data.data);\n                    } else if (data.type === \"connected\") {\n                        console.log(\"SSE connection established\");\n                    }\n                } catch (error) {\n                    console.error(\"Error parsing SSE message:\", error);\n                }\n            };\n            this.eventSource.onerror = (error)=>{\n                console.error(\"SSE connection error:\", error);\n                this.isConnected = false;\n                // Intentar reconectar después de 5 segundos\n                setTimeout(()=>{\n                    var _this_eventSource;\n                    if (((_this_eventSource = this.eventSource) === null || _this_eventSource === void 0 ? void 0 : _this_eventSource.readyState) === EventSource.CLOSED) {\n                        this.initializeSSE();\n                    }\n                }, 5000);\n            };\n        } catch (error) {\n            console.warn(\"SSE not available:\", error);\n            this.isConnected = false;\n        }\n    }\n    async connect() {\n        if (!this.isConnected) {\n            await this.initializeSSE();\n            // Cargar notificaciones existentes\n            await this.loadNotifications();\n        }\n    }\n    disconnect() {\n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n            this.isConnected = false;\n        }\n    }\n    // Cargar notificaciones desde la API\n    async loadNotifications() {\n        try {\n            const response = await fetch(\"/api/notifications\");\n            if (response.ok) {\n                const data = await response.json();\n                this.notifications = data.notifications.map((n)=>({\n                        ...n,\n                        createdAt: new Date(n.createdAt)\n                    }));\n            }\n        } catch (error) {\n            console.error(\"Error loading notifications:\", error);\n        }\n    }\n    handleNewNotification(notification) {\n        // Agregar la notificación a la lista\n        this.notifications.unshift(notification);\n        // Mantener solo las últimas 100 notificaciones\n        if (this.notifications.length > 100) {\n            this.notifications = this.notifications.slice(0, 100);\n        }\n        // Notificar a todos los listeners\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(notification);\n            } catch (error) {\n                console.error(\"Error in notification listener:\", error);\n            }\n        });\n        // Mostrar notificación del navegador si está permitido\n        this.showBrowserNotification(notification);\n    }\n    showBrowserNotification(notification) {\n        if (\"Notification\" in window && Notification.permission === \"granted\") {\n            const browserNotification = new Notification(notification.title, {\n                body: notification.message,\n                icon: \"/favicon.ico\",\n                tag: notification.id\n            });\n            // Auto-cerrar después de 5 segundos\n            setTimeout(()=>{\n                browserNotification.close();\n            }, 5000);\n        }\n    }\n    // Método para simular notificaciones cuando WebSocket no está disponible\n    simulateNotification(notification) {\n        const fullNotification = {\n            ...notification,\n            id: Math.random().toString(36).substr(2, 9),\n            createdAt: new Date(),\n            read: false\n        };\n        this.handleNewNotification(fullNotification);\n    }\n    // Suscribirse a notificaciones\n    subscribe(listener) {\n        this.listeners.push(listener);\n        // Retornar función para desuscribirse\n        return ()=>{\n            const index = this.listeners.indexOf(listener);\n            if (index > -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n    }\n    // Obtener todas las notificaciones\n    getNotifications() {\n        return [\n            ...this.notifications\n        ];\n    }\n    // Obtener notificaciones no leídas\n    getUnreadNotifications() {\n        return this.notifications.filter((n)=>!n.read);\n    }\n    // Marcar notificación como leída\n    async markAsRead(notificationId) {\n        try {\n            const response = await fetch(\"/api/notifications/\".concat(notificationId, \"/read\"), {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                const notification = this.notifications.find((n)=>n.id === notificationId);\n                if (notification) {\n                    notification.read = true;\n                }\n            }\n        } catch (error) {\n            console.error(\"Error marking notification as read:\", error);\n        }\n    }\n    // Marcar todas como leídas\n    async markAllAsRead() {\n        try {\n            const response = await fetch(\"/api/notifications/read-all\", {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                this.notifications.forEach((n)=>n.read = true);\n            }\n        } catch (error) {\n            console.error(\"Error marking all notifications as read:\", error);\n        }\n    }\n    // Eliminar notificación\n    removeNotification(notificationId) {\n        const index = this.notifications.findIndex((n)=>n.id === notificationId);\n        if (index > -1) {\n            this.notifications.splice(index, 1);\n        }\n    }\n    // Limpiar todas las notificaciones\n    clearAll() {\n        this.notifications = [];\n    }\n    // Solicitar permisos para notificaciones del navegador\n    async requestNotificationPermission() {\n        if (\"Notification\" in window) {\n            const permission = await Notification.requestPermission();\n            return permission;\n        }\n        return \"denied\";\n    }\n    // Obtener estado de conexión\n    getConnectionStatus() {\n        return this.isConnected;\n    }\n    // Crear notificación en el servidor\n    async createNotification(type, title, message, data) {\n        try {\n            const response = await fetch(\"/api/notifications\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    type,\n                    title,\n                    message,\n                    data\n                })\n            });\n            if (response.ok) {\n                const notification = await response.json();\n                return notification;\n            }\n        } catch (error) {\n            console.error(\"Error creating notification:\", error);\n        }\n    }\n    // Enviar notificación de XP ganado\n    async notifyXPGained(xp, reason) {\n        await this.createNotification(\"GAMIFICATION\", \"\\xa1XP Ganado!\", \"Has ganado \".concat(xp, \" XP por \").concat(reason), {\n            xp,\n            reason\n        });\n    }\n    // Enviar notificación de subida de nivel\n    async notifyLevelUp(newLevel) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Nivel Alcanzado!\", \"\\xa1Felicidades! Has alcanzado el nivel \".concat(newLevel), {\n            level: newLevel\n        });\n    }\n    // Enviar notificación de badge ganado\n    async notifyBadgeEarned(badgeName) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Badge Desbloqueado!\", \"Has desbloqueado el badge: \".concat(badgeName), {\n            badge: badgeName\n        });\n    }\n    constructor(){\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"eventSource\", null);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"listeners\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"notifications\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"isConnected\", false);\n    // No inicializar automáticamente, esperar a que el usuario se conecte\n    }\n}\n// Instancia singleton\nconst notificationService = new NotificationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9ub3RpZmljYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQU1BLE1BQU1BO0lBVUosTUFBY0MsZ0JBQWdCO1FBQzVCLElBQUk7WUFDRixnQ0FBZ0M7WUFDaEMsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSUMsWUFBWTtZQUVuQyxJQUFJLENBQUNELFdBQVcsQ0FBQ0UsTUFBTSxHQUFHO2dCQUN4QkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1lBQ3JCO1lBRUEsSUFBSSxDQUFDTCxXQUFXLENBQUNNLFNBQVMsR0FBRyxDQUFDQztnQkFDNUIsSUFBSTtvQkFDRixNQUFNQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNILE1BQU1DLElBQUk7b0JBRWxDLElBQUlBLEtBQUtHLElBQUksS0FBSyxnQkFBZ0I7d0JBQ2hDLElBQUksQ0FBQ0MscUJBQXFCLENBQUNKLEtBQUtBLElBQUk7b0JBQ3RDLE9BQU8sSUFBSUEsS0FBS0csSUFBSSxLQUFLLGFBQWE7d0JBQ3BDUixRQUFRQyxHQUFHLENBQUM7b0JBQ2Q7Z0JBQ0YsRUFBRSxPQUFPUyxPQUFPO29CQUNkVixRQUFRVSxLQUFLLENBQUMsOEJBQThCQTtnQkFDOUM7WUFDRjtZQUVBLElBQUksQ0FBQ2IsV0FBVyxDQUFDYyxPQUFPLEdBQUcsQ0FBQ0Q7Z0JBQzFCVixRQUFRVSxLQUFLLENBQUMseUJBQXlCQTtnQkFDdkMsSUFBSSxDQUFDUixXQUFXLEdBQUc7Z0JBRW5CLDRDQUE0QztnQkFDNUNVLFdBQVc7d0JBQ0w7b0JBQUosSUFBSSwwQkFBSSxDQUFDZixXQUFXLGNBQWhCLDBEQUFrQmdCLFVBQVUsTUFBS2YsWUFBWWdCLE1BQU0sRUFBRTt3QkFDdkQsSUFBSSxDQUFDbEIsYUFBYTtvQkFDcEI7Z0JBQ0YsR0FBRztZQUNMO1FBRUYsRUFBRSxPQUFPYyxPQUFPO1lBQ2RWLFFBQVFlLElBQUksQ0FBQyxzQkFBc0JM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cEMsTUFBTSxJQUFJLENBQUNQLGtCQUFrQixDQUMzQixVQUNBLHdCQUNBLDJDQUFpRCxPQUFUTyxXQUN4QztZQUFFQyxPQUFPRDtRQUFTO0lBRXRCO0lBRUEsc0NBQXNDO0lBQ3RDLE1BQU1FLGtCQUFrQkMsU0FBaUIsRUFBRTtRQUN6QyxNQUFNLElBQUksQ0FBQ1Ysa0JBQWtCLENBQzNCLFVBQ0EsMkJBQ0EsOEJBQXdDLE9BQVZVLFlBQzlCO1lBQUVDLE9BQU9EO1FBQVU7SUFFdkI7SUF2UUFFLGFBQWM7UUFMZCxzRUFBUXhGLGVBQWtDO1FBQzFDLHNFQUFRb0MsYUFBb0MsRUFBRTtRQUM5QyxzRUFBUVQsaUJBQWdDLEVBQUU7UUFDMUMsc0VBQVF0QixlQUFjO0lBR3BCLHNFQUFzRTtJQUN4RTtBQXdRRjtBQUVBLHNCQUFzQjtBQUNmLE1BQU1vRixzQkFBc0IsSUFBSTNGLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvbm90aWZpY2F0aW9uU2VydmljZS50cz9mMTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlTm90aWZpY2F0aW9ucyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uTGlzdGVuZXIge1xuICAobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pOiB2b2lkO1xufVxuXG5jbGFzcyBOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBldmVudFNvdXJjZTogRXZlbnRTb3VyY2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE5vdGlmaWNhdGlvbkxpc3RlbmVyW10gPSBbXTtcbiAgcHJpdmF0ZSBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXSA9IFtdO1xuICBwcml2YXRlIGlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gTm8gaW5pY2lhbGl6YXIgYXV0b23DoXRpY2FtZW50ZSwgZXNwZXJhciBhIHF1ZSBlbCB1c3VhcmlvIHNlIGNvbmVjdGVcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVNTRSgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uZWN0YXIgYSBTZXJ2ZXItU2VudCBFdmVudHNcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9hcGkvbm90aWZpY2F0aW9ucy9zdHJlYW0nKTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gbm90aWZpY2F0aW9uIHN0cmVhbScpO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ25vdGlmaWNhdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTmV3Tm90aWZpY2F0aW9uKGRhdGEuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU1NFIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBTU0UgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTU0UgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIEludGVudGFyIHJlY29uZWN0YXIgZGVzcHXDqXMgZGUgNSBzZWd1bmRvc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudFNvdXJjZT8ucmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTU0UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMDApO1xuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NTRSBub3QgYXZhaWxhYmxlOicsIGVycm9yKTtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplU1NFKCk7XG4gICAgICAvLyBDYXJnYXIgbm90aWZpY2FjaW9uZXMgZXhpc3RlbnRlc1xuICAgICAgYXdhaXQgdGhpcy5sb2FkTm90aWZpY2F0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhcmdhciBub3RpZmljYWNpb25lcyBkZXNkZSBsYSBBUElcbiAgcHJpdmF0ZSBhc3luYyBsb2FkTm90aWZpY2F0aW9ucygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zJyk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gZGF0YS5ub3RpZmljYXRpb25zLm1hcCgobjogYW55KSA9PiAoe1xuICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShuLmNyZWF0ZWRBdClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG5vdGlmaWNhdGlvbnM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTmV3Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uKSB7XG4gICAgLy8gQWdyZWdhciBsYSBub3RpZmljYWNpw7NuIGEgbGEgbGlzdGFcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb24pO1xuICAgIFxuICAgIC8vIE1hbnRlbmVyIHNvbG8gbGFzIMO6bHRpbWFzIDEwMCBub3RpZmljYWNpb25lc1xuICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSB0aGlzLm5vdGlmaWNhdGlvbnMuc2xpY2UoMCwgMTAwKTtcbiAgICB9XG5cbiAgICAvLyBOb3RpZmljYXIgYSB0b2RvcyBsb3MgbGlzdGVuZXJzXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcihub3RpZmljYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbm90aWZpY2F0aW9uIGxpc3RlbmVyOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1vc3RyYXIgbm90aWZpY2FjacOzbiBkZWwgbmF2ZWdhZG9yIHNpIGVzdMOhIHBlcm1pdGlkb1xuICAgIHRoaXMuc2hvd0Jyb3dzZXJOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvd0Jyb3dzZXJOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pIHtcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXJOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbi50aXRsZSwge1xuICAgICAgICBib2R5OiBub3RpZmljYXRpb24ubWVzc2FnZSxcbiAgICAgICAgaWNvbjogJy9mYXZpY29uLmljbycsXG4gICAgICAgIHRhZzogbm90aWZpY2F0aW9uLmlkXG4gICAgICB9KTtcblxuICAgICAgLy8gQXV0by1jZXJyYXIgZGVzcHXDqXMgZGUgNSBzZWd1bmRvc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJyb3dzZXJOb3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIE3DqXRvZG8gcGFyYSBzaW11bGFyIG5vdGlmaWNhY2lvbmVzIGN1YW5kbyBXZWJTb2NrZXQgbm8gZXN0w6EgZGlzcG9uaWJsZVxuICBzaW11bGF0ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE9taXQ8Tm90aWZpY2F0aW9uLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAncmVhZCc+KSB7XG4gICAgY29uc3QgZnVsbE5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uID0ge1xuICAgICAgLi4ubm90aWZpY2F0aW9uLFxuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHJlYWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlTmV3Tm90aWZpY2F0aW9uKGZ1bGxOb3RpZmljYXRpb24pO1xuICB9XG5cbiAgLy8gU3VzY3JpYmlyc2UgYSBub3RpZmljYWNpb25lc1xuICBzdWJzY3JpYmUobGlzdGVuZXI6IE5vdGlmaWNhdGlvbkxpc3RlbmVyKTogKCkgPT4gdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgXG4gICAgLy8gUmV0b3JuYXIgZnVuY2nDs24gcGFyYSBkZXN1c2NyaWJpcnNlXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBPYnRlbmVyIHRvZGFzIGxhcyBub3RpZmljYWNpb25lc1xuICBnZXROb3RpZmljYXRpb25zKCk6IE5vdGlmaWNhdGlvbltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubm90aWZpY2F0aW9uc107XG4gIH1cblxuICAvLyBPYnRlbmVyIG5vdGlmaWNhY2lvbmVzIG5vIGxlw61kYXNcbiAgZ2V0VW5yZWFkTm90aWZpY2F0aW9ucygpOiBOb3RpZmljYXRpb25bXSB7XG4gICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9ucy5maWx0ZXIobiA9PiAhbi5yZWFkKTtcbiAgfVxuXG4gIC8vIE1hcmNhciBub3RpZmljYWNpw7NuIGNvbW8gbGXDrWRhXG4gIGFzeW5jIG1hcmtBc1JlYWQobm90aWZpY2F0aW9uSWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL25vdGlmaWNhdGlvbnMvJHtub3RpZmljYXRpb25JZH0vcmVhZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHRoaXMubm90aWZpY2F0aW9ucy5maW5kKG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLnJlYWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1hcmtpbmcgbm90aWZpY2F0aW9uIGFzIHJlYWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1hcmNhciB0b2RhcyBjb21vIGxlw61kYXNcbiAgYXN5bmMgbWFya0FsbEFzUmVhZCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zL3JlYWQtYWxsJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmZvckVhY2gobiA9PiBuLnJlYWQgPSB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFya2luZyBhbGwgbm90aWZpY2F0aW9ucyBhcyByZWFkOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbGltaW5hciBub3RpZmljYWNpw7NuXG4gIHJlbW92ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JZDogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm5vdGlmaWNhdGlvbnMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaW1waWFyIHRvZGFzIGxhcyBub3RpZmljYWNpb25lc1xuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBbXTtcbiAgfVxuXG4gIC8vIFNvbGljaXRhciBwZXJtaXNvcyBwYXJhIG5vdGlmaWNhY2lvbmVzIGRlbCBuYXZlZ2Fkb3JcbiAgYXN5bmMgcmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24oKTogUHJvbWlzZTxOb3RpZmljYXRpb25QZXJtaXNzaW9uPiB7XG4gICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdykge1xuICAgICAgY29uc3QgcGVybWlzc2lvbiA9IGF3YWl0IE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgICAgcmV0dXJuIHBlcm1pc3Npb247XG4gICAgfVxuICAgIHJldHVybiAnZGVuaWVkJztcbiAgfVxuXG4gIC8vIE9idGVuZXIgZXN0YWRvIGRlIGNvbmV4acOzblxuICBnZXRDb25uZWN0aW9uU3RhdHVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xuICB9XG5cbiAgLy8gQ3JlYXIgbm90aWZpY2FjacOzbiBlbiBlbCBzZXJ2aWRvclxuICBhc3luYyBjcmVhdGVOb3RpZmljYXRpb24odHlwZTogTm90aWZpY2F0aW9uWyd0eXBlJ10sIHRpdGxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL25vdGlmaWNhdGlvbnMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBub3RpZmljYXRpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVudmlhciBub3RpZmljYWNpw7NuIGRlIFhQIGdhbmFkb1xuICBhc3luYyBub3RpZnlYUEdhaW5lZCh4cDogbnVtYmVyLCByZWFzb246IHN0cmluZykge1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKFxuICAgICAgJ0dBTUlGSUNBVElPTicsXG4gICAgICAnwqFYUCBHYW5hZG8hJyxcbiAgICAgIGBIYXMgZ2FuYWRvICR7eHB9IFhQIHBvciAke3JlYXNvbn1gLFxuICAgICAgeyB4cCwgcmVhc29uIH1cbiAgICApO1xuICB9XG5cbiAgLy8gRW52aWFyIG5vdGlmaWNhY2nDs24gZGUgc3ViaWRhIGRlIG5pdmVsXG4gIGFzeW5jIG5vdGlmeUxldmVsVXAobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKFxuICAgICAgJ1NZU1RFTScsXG4gICAgICAnwqFOaXZlbCBBbGNhbnphZG8hJyxcbiAgICAgIGDCoUZlbGljaWRhZGVzISBIYXMgYWxjYW56YWRvIGVsIG5pdmVsICR7bmV3TGV2ZWx9YCxcbiAgICAgIHsgbGV2ZWw6IG5ld0xldmVsIH1cbiAgICApO1xuICB9XG5cbiAgLy8gRW52aWFyIG5vdGlmaWNhY2nDs24gZGUgYmFkZ2UgZ2FuYWRvXG4gIGFzeW5jIG5vdGlmeUJhZGdlRWFybmVkKGJhZGdlTmFtZTogc3RyaW5nKSB7XG4gICAgYXdhaXQgdGhpcy5jcmVhdGVOb3RpZmljYXRpb24oXG4gICAgICAnU1lTVEVNJyxcbiAgICAgICfCoUJhZGdlIERlc2Jsb3F1ZWFkbyEnLFxuICAgICAgYEhhcyBkZXNibG9xdWVhZG8gZWwgYmFkZ2U6ICR7YmFkZ2VOYW1lfWAsXG4gICAgICB7IGJhZGdlOiBiYWRnZU5hbWUgfVxuICAgICk7XG4gIH1cblxuXG59XG5cbi8vIEluc3RhbmNpYSBzaW5nbGV0b25cbmV4cG9ydCBjb25zdCBub3RpZmljYXRpb25TZXJ2aWNlID0gbmV3IE5vdGlmaWNhdGlvblNlcnZpY2UoKTsiXSwibmFtZXMiOlsiTm90aWZpY2F0aW9uU2VydmljZSIsImluaXRpYWxpemVTU0UiLCJldmVudFNvdXJjZSIsIkV2ZW50U291cmNlIiwib25vcGVuIiwiY29uc29sZSIsImxvZyIsImlzQ29ubmVjdGVkIiwib25tZXNzYWdlIiwiZXZlbnQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwidHlwZSIsImhhbmRsZU5ld05vdGlmaWNhdGlvbiIsImVycm9yIiwib25lcnJvciIsInNldFRpbWVvdXQiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwid2FybiIsImNvbm5lY3QiLCJsb2FkTm90aWZpY2F0aW9ucyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImpzb24iLCJub3RpZmljYXRpb25zIiwibWFwIiwibiIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3RpZmljYXRpb24iLCJ1bnNoaWZ0IiwibGVuZ3RoIiwic2xpY2UiLCJsaXN0ZW5lcnMiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJzaG93QnJvd3Nlck5vdGlmaWNhdGlvbiIsIndpbmRvdyIsIk5vdGlmaWNhdGlvbiIsInBlcm1pc3Npb24iLCJicm93c2VyTm90aWZpY2F0aW9uIiwidGl0bGUiLCJib2R5IiwibWVzc2FnZSIsImljb24iLCJ0YWciLCJpZCIsInNpbXVsYXRlTm90aWZpY2F0aW9uIiwiZnVsbE5vdGlmaWNhdGlvbiIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInJlYWQiLCJzdWJzY3JpYmUiLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZ2V0Tm90aWZpY2F0aW9ucyIsImdldFVucmVhZE5vdGlmaWNhdGlvbnMiLCJmaWx0ZXIiLCJtYXJrQXNSZWFkIiwibm90aWZpY2F0aW9uSWQiLCJtZXRob2QiLCJmaW5kIiwibWFya0FsbEFzUmVhZCIsInJlbW92ZU5vdGlmaWNhdGlvbiIsImZpbmRJbmRleCIsImNsZWFyQWxsIiwicmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24iLCJyZXF1ZXN0UGVybWlzc2lvbiIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJjcmVhdGVOb3RpZmljYXRpb24iLCJoZWFkZXJzIiwic3RyaW5naWZ5Iiwibm90aWZ5WFBHYWluZWQiLCJ4cCIsInJlYXNvbiIsIm5vdGlmeUxldmVsVXAiLCJuZXdMZXZlbCIsImxldmVsIiwibm90aWZ5QmFkZ2VFYXJuZWQiLCJiYWRnZU5hbWUiLCJiYWRnZSIsImNvbnN0cnVjdG9yIiwibm90aWZpY2F0aW9uU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/notificationService.ts\n"));

/***/ })

});