"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gamification/page",{

/***/ "(app-pages-browser)/./src/services/gamificationService.ts":
/*!*********************************************!*\
  !*** ./src/services/gamificationService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LEVELS: function() { return /* binding */ LEVELS; },\n/* harmony export */   XP_REWARDS: function() { return /* binding */ XP_REWARDS; },\n/* harmony export */   calculateUserLevel: function() { return /* binding */ calculateUserLevel; },\n/* harmony export */   gamificationService: function() { return /* binding */ gamificationService; },\n/* harmony export */   getXpToNextLevel: function() { return /* binding */ getXpToNextLevel; }\n/* harmony export */ });\n// Configuración de niveles\nconst LEVELS = [\n    {\n        level: 1,\n        name: \"Novato\",\n        minXp: 0,\n        maxXp: 100,\n        rewards: {\n            crolars: 50\n        }\n    },\n    {\n        level: 2,\n        name: \"Aprendiz\",\n        minXp: 100,\n        maxXp: 250,\n        rewards: {\n            crolars: 75\n        }\n    },\n    {\n        level: 3,\n        name: \"Estudiante\",\n        minXp: 250,\n        maxXp: 500,\n        rewards: {\n            crolars: 100,\n            badges: [\n                \"Primer Paso\"\n            ]\n        }\n    },\n    {\n        level: 4,\n        name: \"Dedicado\",\n        minXp: 500,\n        maxXp: 850,\n        rewards: {\n            crolars: 125\n        }\n    },\n    {\n        level: 5,\n        name: \"Comprometido\",\n        minXp: 850,\n        maxXp: 1300,\n        rewards: {\n            crolars: 150,\n            badges: [\n                \"Constancia\"\n            ]\n        }\n    },\n    {\n        level: 6,\n        name: \"Avanzado\",\n        minXp: 1300,\n        maxXp: 1850,\n        rewards: {\n            crolars: 200\n        }\n    },\n    {\n        level: 7,\n        name: \"Experto\",\n        minXp: 1850,\n        maxXp: 2500,\n        rewards: {\n            crolars: 250\n        }\n    },\n    {\n        level: 8,\n        name: \"Maestro\",\n        minXp: 2500,\n        maxXp: 3300,\n        rewards: {\n            crolars: 300,\n            badges: [\n                \"Maestr\\xeda\"\n            ]\n        }\n    },\n    {\n        level: 9,\n        name: \"Sabio\",\n        minXp: 3300,\n        maxXp: 4250,\n        rewards: {\n            crolars: 400\n        }\n    },\n    {\n        level: 10,\n        name: \"Leyenda\",\n        minXp: 4250,\n        maxXp: 5350,\n        rewards: {\n            crolars: 500,\n            badges: [\n                \"Leyenda Acad\\xe9mica\"\n            ]\n        }\n    },\n    {\n        level: 11,\n        name: \"Tit\\xe1n\",\n        minXp: 5350,\n        maxXp: 6600,\n        rewards: {\n            crolars: 600\n        }\n    },\n    {\n        level: 12,\n        name: \"Inmortal\",\n        minXp: 6600,\n        maxXp: 8100,\n        rewards: {\n            crolars: 750,\n            badges: [\n                \"Inmortal del Saber\"\n            ]\n        }\n    },\n    {\n        level: 13,\n        name: \"Divino\",\n        minXp: 8100,\n        maxXp: 10000,\n        rewards: {\n            crolars: 1000\n        }\n    },\n    {\n        level: 14,\n        name: \"Trascendente\",\n        minXp: 10000,\n        maxXp: 12500,\n        rewards: {\n            crolars: 1250,\n            badges: [\n                \"Trascendencia\"\n            ]\n        }\n    },\n    {\n        level: 15,\n        name: \"Omnisciente\",\n        minXp: 12500,\n        maxXp: Infinity,\n        rewards: {\n            crolars: 1500,\n            badges: [\n                \"Omnisciencia\"\n            ]\n        }\n    }\n];\n// Configuración de XP por actividad\nconst XP_REWARDS = {\n    COURSE_LESSON_COMPLETE: 25,\n    COURSE_COMPLETE: 200,\n    CHALLENGE_COMPLETE: 100,\n    FORUM_QUESTION: 15,\n    FORUM_ANSWER: 20,\n    FORUM_BEST_ANSWER: 50,\n    NOTE_UPLOAD: 10,\n    NOTE_SHARED: 5,\n    EVENT_ATTEND: 30,\n    CLUB_JOIN: 20,\n    CLUB_POST: 10,\n    DAILY_STREAK: 15,\n    WEEKLY_STREAK: 100,\n    MONTHLY_STREAK: 500,\n    ACHIEVEMENT_UNLOCK: 50,\n    BADGE_EARN: 25\n};\nclass GamificationService {\n    // Calcular nivel basado en XP\n    calculateLevel(totalXp) {\n        for(let i = LEVELS.length - 1; i >= 0; i--){\n            if (totalXp >= LEVELS[i].minXp) {\n                return LEVELS[i];\n            }\n        }\n        return LEVELS[0];\n    }\n    // Calcular XP necesario para el siguiente nivel\n    getXpToNextLevel(currentXp) {\n        const currentLevel = this.calculateLevel(currentXp);\n        const nextLevel = LEVELS.find((l)=>l.level === currentLevel.level + 1);\n        if (!nextLevel) {\n            return {\n                needed: 0,\n                total: 0\n            };\n        }\n        return {\n            needed: nextLevel.minXp - currentXp,\n            total: nextLevel.minXp - currentLevel.minXp\n        };\n    }\n    // Otorgar XP a un usuario\n    async grantXP(userId, amount, source, sourceId, description) {\n        // En una implementación real, esto interactuaría con la base de datos\n        const user = await this.getUser(userId);\n        const oldLevel = this.calculateLevel(user.totalXp);\n        user.xp += amount;\n        user.totalXp += amount;\n        const newLevel = this.calculateLevel(user.totalXp);\n        const levelUp = newLevel.level > oldLevel.level;\n        const notifications = [];\n        // Notificación de XP ganado\n        notifications.push({\n            id: \"xp_\".concat(Date.now()),\n            userId,\n            type: \"xp_gain\",\n            title: \"XP Ganado\",\n            message: \"Has ganado \".concat(amount, \" XP por \").concat(description),\n            data: {\n                amount,\n                source,\n                sourceId\n            },\n            read: false,\n            createdAt: new Date().toISOString()\n        });\n        // Si subió de nivel\n        if (levelUp) {\n            user.level = newLevel.level;\n            user.crolars += newLevel.rewards.crolars;\n            notifications.push({\n                id: \"level_\".concat(Date.now()),\n                userId,\n                type: \"level_up\",\n                title: \"\\xa1Subiste de Nivel!\",\n                message: \"\\xa1Felicidades! Ahora eres \".concat(newLevel.name, \" (Nivel \").concat(newLevel.level, \")\"),\n                data: {\n                    newLevel,\n                    rewards: newLevel.rewards\n                },\n                read: false,\n                createdAt: new Date().toISOString()\n            });\n            // Otorgar badges de nivel si los hay\n            if (newLevel.rewards.badges) {\n                for (const badgeName of newLevel.rewards.badges){\n                    const badge = await this.grantBadge(userId, badgeName);\n                    if (badge) {\n                        notifications.push({\n                            id: \"badge_\".concat(Date.now(), \"_\").concat(badge.id),\n                            userId,\n                            type: \"badge_earned\",\n                            title: \"\\xa1Nueva Insignia!\",\n                            message: \"Has desbloqueado la insignia: \".concat(badge.name),\n                            data: {\n                                badge\n                            },\n                            read: false,\n                            createdAt: new Date().toISOString()\n                        });\n                    }\n                }\n            }\n        }\n        // Guardar cambios del usuario\n        await this.updateUser(user);\n        // Registrar ganancia de XP\n        await this.logXPGain({\n            id: \"xp_\".concat(userId, \"_\").concat(Date.now()),\n            userId,\n            amount,\n            source,\n            sourceId,\n            description,\n            timestamp: new Date().toISOString()\n        });\n        return {\n            levelUp,\n            newLevel: levelUp ? newLevel : undefined,\n            notifications\n        };\n    }\n    // Otorgar badge a un usuario\n    async grantBadge(userId, badgeName) {\n        const user = await this.getUser(userId);\n        // Verificar si ya tiene el badge\n        if (user.badges.some((b)=>b.name === badgeName)) {\n            return null;\n        }\n        const badge = await this.getBadgeByName(badgeName);\n        if (!badge) return null;\n        badge.earnedAt = new Date().toISOString();\n        user.badges.push(badge);\n        await this.updateUser(user);\n        return badge;\n    }\n    // Verificar y desbloquear logros\n    async checkAchievements(userId) {\n        const user = await this.getUser(userId);\n        const unlockedAchievements = [];\n        // Obtener logros disponibles que el usuario no ha desbloqueado\n        const availableAchievements = await this.getAvailableAchievements(userId);\n        for (const achievement of availableAchievements){\n            if (this.checkAchievementRequirements(user, achievement)) {\n                achievement.earned = true;\n                achievement.earnedDate = new Date().toISOString();\n                // Otorgar recompensas del logro\n                await this.grantXP(userId, achievement.reward.xp, \"achievement\", achievement.id, \"Logro desbloqueado: \".concat(achievement.title));\n                user.crolars += achievement.reward.crolars;\n                if (achievement.reward.badge) {\n                    await this.grantBadge(userId, achievement.reward.badge);\n                }\n                unlockedAchievements.push(achievement);\n            }\n        }\n        if (unlockedAchievements.length > 0) {\n            await this.updateUser(user);\n        }\n        return unlockedAchievements;\n    }\n    // Verificar requisitos de un logro\n    checkAchievementRequirements(user, achievement) {\n        switch(achievement.id){\n            case \"first_course\":\n                return user.stats.coursesCompleted >= 1;\n            case \"course_master\":\n                return user.stats.coursesCompleted >= 10;\n            case \"challenge_warrior\":\n                return user.stats.challengesCompleted >= 5;\n            case \"forum_helper\":\n                return user.stats.forumAnswers >= 10;\n            case \"streak_keeper\":\n                return user.streak.current >= 7;\n            case \"social_butterfly\":\n                return user.stats.friendsCount >= 20;\n            case \"knowledge_sharer\":\n                return user.stats.notesUploaded >= 50;\n            case \"event_enthusiast\":\n                return user.stats.eventsAttended >= 5;\n            case \"club_leader\":\n                return user.stats.clubsJoined >= 3;\n            case \"study_marathon\":\n                return user.stats.totalStudyTime >= 1000 // 1000 minutos\n                ;\n            default:\n                return false;\n        }\n    }\n    // Actualizar racha diaria\n    async updateDailyStreak(userId) {\n        const user = await this.getUser(userId);\n        const today = new Date().toDateString();\n        const lastActivity = new Date(user.streak.lastActivity).toDateString();\n        const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();\n        const notifications = [];\n        if (lastActivity === today) {\n            // Ya registró actividad hoy\n            return {\n                streakUpdated: false,\n                notifications\n            };\n        }\n        if (lastActivity === yesterday) {\n            // Continúa la racha\n            user.streak.current += 1;\n            user.streak.lastActivity = new Date().toISOString();\n            if (user.streak.current > user.streak.longest) {\n                user.streak.longest = user.streak.current;\n            }\n            // Otorgar XP por racha\n            let xpReward = XP_REWARDS.DAILY_STREAK;\n            if (user.streak.current % 7 === 0) {\n                xpReward = XP_REWARDS.WEEKLY_STREAK;\n            } else if (user.streak.current % 30 === 0) {\n                xpReward = XP_REWARDS.MONTHLY_STREAK;\n            }\n            const xpResult = await this.grantXP(userId, xpReward, \"streak\", \"daily\", \"Racha de \".concat(user.streak.current, \" d\\xedas\"));\n            notifications.push(...xpResult.notifications);\n            // Notificación de racha\n            if (user.streak.current % 7 === 0) {\n                notifications.push({\n                    id: \"streak_\".concat(Date.now()),\n                    userId,\n                    type: \"streak_milestone\",\n                    title: \"\\xa1Racha Semanal!\",\n                    message: \"\\xa1Incre\\xedble! Has mantenido una racha de \".concat(user.streak.current, \" d\\xedas\"),\n                    data: {\n                        streak: user.streak.current\n                    },\n                    read: false,\n                    createdAt: new Date().toISOString()\n                });\n            }\n        } else {\n            // Se rompió la racha\n            user.streak.current = 1;\n            user.streak.lastActivity = new Date().toISOString();\n        }\n        await this.updateUser(user);\n        return {\n            streakUpdated: true,\n            notifications\n        };\n    }\n    // Métodos auxiliares (en una implementación real, estos interactuarían con la base de datos)\n    async getUser(userId) {\n        // Implementación mock - en producción vendría de la base de datos\n        throw new Error(\"Method not implemented - requires database integration\");\n    }\n    async updateUser(user) {\n        // Implementación mock - en producción actualizaría la base de datos\n        throw new Error(\"Method not implemented - requires database integration\");\n    }\n    async logXPGain(xpGain) {\n        // Implementación mock - en producción guardaría en la base de datos\n        throw new Error(\"Method not implemented - requires database integration\");\n    }\n    async getBadgeByName(name) {\n        // Implementación mock - en producción vendría de la base de datos\n        throw new Error(\"Method not implemented - requires database integration\");\n    }\n    async getAvailableAchievements(userId) {\n        // Implementación mock - en producción vendría de la base de datos\n        throw new Error(\"Method not implemented - requires database integration\");\n    }\n}\nconst gamificationService = new GamificationService();\n// Exportar funciones de utilidad\nconst calculateUserLevel = (totalXp)=>{\n    for(let i = LEVELS.length - 1; i >= 0; i--){\n        if (totalXp >= LEVELS[i].minXp) {\n            return LEVELS[i];\n        }\n    }\n    return LEVELS[0];\n};\nconst getXpToNextLevel = (currentXp)=>{\n    const currentLevel = calculateUserLevel(currentXp);\n    const nextLevel = LEVELS.find((l)=>l.level === currentLevel.level + 1);\n    if (!nextLevel) {\n        return {\n            needed: 0,\n            total: 0\n        };\n    }\n    return {\n        needed: nextLevel.minXp - currentXp,\n        total: nextLevel.minXp - currentLevel.minXp\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9nYW1pZmljYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRUEsMkJBQTJCO0FBQ3BCLE1BQU1BLFNBQWtCO0lBQzdCO1FBQUVDLE9BQU87UUFBR0MsTUFBTTtRQUFVQyxPQUFPO1FBQUdDLE9BQU87UUFBS0MsU0FBUztZQUFFQyxTQUFTO1FBQUc7SUFBRTtJQUMzRTtRQUFFTCxPQUFPO1FBQUdDLE1BQU07UUFBWUMsT0FBTztRQUFLQyxPQUFPO1FBQUtDLFNBQVM7WUFBRUMsU0FBUztRQUFHO0lBQUU7SUFDL0U7UUFBRUwsT0FBTztRQUFHQyxNQUFNO1FBQWNDLE9BQU87UUFBS0MsT0FBTztRQUFLQyxTQUFTO1lBQUVDLFNBQVM7WUFBS0MsUUFBUTtnQkFBQzthQUFjO1FBQUM7SUFBRTtJQUMzRztRQUFFTixPQUFPO1FBQUdDLE1BQU07UUFBWUMsT0FBTztRQUFLQyxPQUFPO1FBQUtDLFNBQVM7WUFBRUMsU0FBUztRQUFJO0lBQUU7SUFDaEY7UUFBRUwsT0FBTztRQUFHQyxNQUFNO1FBQWdCQyxPQUFPO1FBQUtDLE9BQU87UUFBTUMsU0FBUztZQUFFQyxTQUFTO1lBQUtDLFFBQVE7Z0JBQUM7YUFBYTtRQUFDO0lBQUU7SUFDN0c7UUFBRU4sT0FBTztRQUFHQyxNQUFNO1FBQVlDLE9BQU87UUFBTUMsT0FBTztRQUFNQyxTQUFTO1lBQUVDLFNBQVM7UUFBSTtJQUFFO0lBQ2xGO1FBQUVMLE9BQU87UUFBR0MsTUFBTTtRQUFXQyxPQUFPO1FBQU1DLE9BQU87UUFBTUMsU0FBUztZQUFFQyxTQUFTO1FBQUk7SUFBRTtJQUNqRjtRQUFFTCxPQUFPO1FBQUdDLE1BQU07UUFBV0MsT0FBTztRQUFNQyxPQUFPO1FBQU1DLFNBQVM7WUFBRUMsU0FBUztZQUFLQyxRQUFRO2dCQUFDO2FBQVc7UUFBQztJQUFFO0lBQ3ZHO1FBQUVOLE9BQU87UUFBR0MsTUFBTTtRQUFTQyxPQUFPO1FBQU1DLE9B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LEdBQUc7SUFFcEUsSUFBSSxDQUFDaUMsV0FBVztRQUNkLE9BQU87WUFBRUcsUUFBUTtZQUFHQyxPQUFPO1FBQUU7SUFDL0I7SUFFQSxPQUFPO1FBQ0xELFFBQVFILFVBQVUvQixLQUFLLEdBQUc2QjtRQUMxQk0sT0FBT0osVUFBVS9CLEtBQUssR0FBRzhCLGFBQWE5QixLQUFLO0lBQzdDO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvZ2FtaWZpY2F0aW9uU2VydmljZS50cz8zNzQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVzZXIsIExldmVsLCBYUEdhaW4sIEJhZGdlLCBBY2hpZXZlbWVudCwgTm90aWZpY2F0aW9uIH0gZnJvbSAnQC90eXBlcy9nYW1pZmljYXRpb24nXHJcblxyXG4vLyBDb25maWd1cmFjacOzbiBkZSBuaXZlbGVzXHJcbmV4cG9ydCBjb25zdCBMRVZFTFM6IExldmVsW10gPSBbXHJcbiAgeyBsZXZlbDogMSwgbmFtZTogJ05vdmF0bycsIG1pblhwOiAwLCBtYXhYcDogMTAwLCByZXdhcmRzOiB7IGNyb2xhcnM6IDUwIH0gfSxcclxuICB7IGxldmVsOiAyLCBuYW1lOiAnQXByZW5kaXonLCBtaW5YcDogMTAwLCBtYXhYcDogMjUwLCByZXdhcmRzOiB7IGNyb2xhcnM6IDc1IH0gfSxcclxuICB7IGxldmVsOiAzLCBuYW1lOiAnRXN0dWRpYW50ZScsIG1pblhwOiAyNTAsIG1heFhwOiA1MDAsIHJld2FyZHM6IHsgY3JvbGFyczogMTAwLCBiYWRnZXM6IFsnUHJpbWVyIFBhc28nXSB9IH0sXHJcbiAgeyBsZXZlbDogNCwgbmFtZTogJ0RlZGljYWRvJywgbWluWHA6IDUwMCwgbWF4WHA6IDg1MCwgcmV3YXJkczogeyBjcm9sYXJzOiAxMjUgfSB9LFxyXG4gIHsgbGV2ZWw6IDUsIG5hbWU6ICdDb21wcm9tZXRpZG8nLCBtaW5YcDogODUwLCBtYXhYcDogMTMwMCwgcmV3YXJkczogeyBjcm9sYXJzOiAxNTAsIGJhZGdlczogWydDb25zdGFuY2lhJ10gfSB9LFxyXG4gIHsgbGV2ZWw6IDYsIG5hbWU6ICdBdmFuemFkbycsIG1pblhwOiAxMzAwLCBtYXhYcDogMTg1MCwgcmV3YXJkczogeyBjcm9sYXJzOiAyMDAgfSB9LFxyXG4gIHsgbGV2ZWw6IDcsIG5hbWU6ICdFeHBlcnRvJywgbWluWHA6IDE4NTAsIG1heFhwOiAyNTAwLCByZXdhcmRzOiB7IGNyb2xhcnM6IDI1MCB9IH0sXHJcbiAgeyBsZXZlbDogOCwgbmFtZTogJ01hZXN0cm8nLCBtaW5YcDogMjUwMCwgbWF4WHA6IDMzMDAsIHJld2FyZHM6IHsgY3JvbGFyczogMzAwLCBiYWRnZXM6IFsnTWFlc3Ryw61hJ10gfSB9LFxyXG4gIHsgbGV2ZWw6IDksIG5hbWU6ICdTYWJpbycsIG1pblhwOiAzMzAwLCBtYXhYcDogNDI1MCwgcmV3YXJkczogeyBjcm9sYXJzOiA0MDAgfSB9LFxyXG4gIHsgbGV2ZWw6IDEwLCBuYW1lOiAnTGV5ZW5kYScsIG1pblhwOiA0MjUwLCBtYXhYcDogNTM1MCwgcmV3YXJkczogeyBjcm9sYXJzOiA1MDAsIGJhZGdlczogWydMZXllbmRhIEFjYWTDqW1pY2EnXSB9IH0sXHJcbiAgeyBsZXZlbDogMTEsIG5hbWU6ICdUaXTDoW4nLCBtaW5YcDogNTM1MCwgbWF4WHA6IDY2MDAsIHJld2FyZHM6IHsgY3JvbGFyczogNjAwIH0gfSxcclxuICB7IGxldmVsOiAxMiwgbmFtZTogJ0lubW9ydGFsJywgbWluWHA6IDY2MDAsIG1heFhwOiA4MTAwLCByZXdhcmRzOiB7IGNyb2xhcnM6IDc1MCwgYmFkZ2VzOiBbJ0lubW9ydGFsIGRlbCBTYWJlciddIH0gfSxcclxuICB7IGxldmVsOiAxMywgbmFtZTogJ0RpdmlubycsIG1pblhwOiA4MTAwLCBtYXhYcDogMTAwMDAsIHJld2FyZHM6IHsgY3JvbGFyczogMTAwMCB9IH0sXHJcbiAgeyBsZXZlbDogMTQsIG5hbWU6ICdUcmFzY2VuZGVudGUnLCBtaW5YcDogMTAwMDAsIG1heFhwOiAxMjUwMCwgcmV3YXJkczogeyBjcm9sYXJzOiAxMjUwLCBiYWRnZXM6IFsnVHJhc2NlbmRlbmNpYSddIH0gfSxcclxuICB7IGxldmVsOiAxNSwgbmFtZTogJ09tbmlzY2llbnRlJywgbWluWHA6IDEyNTAwLCBtYXhYcDogSW5maW5pdHksIHJld2FyZHM6IHsgY3JvbGFyczogMTUwMCwgYmFkZ2VzOiBbJ09tbmlzY2llbmNpYSddIH0gfVxyXG5dXHJcblxyXG4vLyBDb25maWd1cmFjacOzbiBkZSBYUCBwb3IgYWN0aXZpZGFkXHJcbmV4cG9ydCBjb25zdCBYUF9SRVdBUkRTID0ge1xyXG4gIENPVVJTRV9MRVNTT05fQ09NUExFVEU6IDI1LFxyXG4gIENPVVJTRV9DT01QTEVURTogMjAwLFxyXG4gIENIQUxMRU5HRV9DT01QTEVURTogMTAwLFxyXG4gIEZPUlVNX1FVRVNUSU9OOiAxNSxcclxuICBGT1JVTV9BTlNXRVI6IDIwLFxyXG4gIEZPUlVNX0JFU1RfQU5TV0VSOiA1MCxcclxuICBOT1RFX1VQTE9BRDogMTAsXHJcbiAgTk9URV9TSEFSRUQ6IDUsXHJcbiAgRVZFTlRfQVRURU5EOiAzMCxcclxuICBDTFVCX0pPSU46IDIwLFxyXG4gIENMVUJfUE9TVDogMTAsXHJcbiAgREFJTFlfU1RSRUFLOiAxNSxcclxuICBXRUVLTFlfU1RSRUFLOiAxMDAsXHJcbiAgTU9OVEhMWV9TVFJFQUs6IDUwMCxcclxuICBBQ0hJRVZFTUVOVF9VTkxPQ0s6IDUwLFxyXG4gIEJBREdFX0VBUk46IDI1XHJcbn1cclxuXHJcbmNsYXNzIEdhbWlmaWNhdGlvblNlcnZpY2Uge1xyXG4gIC8vIENhbGN1bGFyIG5pdmVsIGJhc2FkbyBlbiBYUFxyXG4gIGNhbGN1bGF0ZUxldmVsKHRvdGFsWHA6IG51bWJlcik6IExldmVsIHtcclxuICAgIGZvciAobGV0IGkgPSBMRVZFTFMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYgKHRvdGFsWHAgPj0gTEVWRUxTW2ldLm1pblhwKSB7XHJcbiAgICAgICAgcmV0dXJuIExFVkVMU1tpXVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTEVWRUxTWzBdXHJcbiAgfVxyXG5cclxuICAvLyBDYWxjdWxhciBYUCBuZWNlc2FyaW8gcGFyYSBlbCBzaWd1aWVudGUgbml2ZWxcclxuICBnZXRYcFRvTmV4dExldmVsKGN1cnJlbnRYcDogbnVtYmVyKTogeyBuZWVkZWQ6IG51bWJlcjsgdG90YWw6IG51bWJlciB9IHtcclxuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuY2FsY3VsYXRlTGV2ZWwoY3VycmVudFhwKVxyXG4gICAgY29uc3QgbmV4dExldmVsID0gTEVWRUxTLmZpbmQobCA9PiBsLmxldmVsID09PSBjdXJyZW50TGV2ZWwubGV2ZWwgKyAxKVxyXG4gICAgXHJcbiAgICBpZiAoIW5leHRMZXZlbCkge1xyXG4gICAgICByZXR1cm4geyBuZWVkZWQ6IDAsIHRvdGFsOiAwIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmVlZGVkOiBuZXh0TGV2ZWwubWluWHAgLSBjdXJyZW50WHAsXHJcbiAgICAgIHRvdGFsOiBuZXh0TGV2ZWwubWluWHAgLSBjdXJyZW50TGV2ZWwubWluWHBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIE90b3JnYXIgWFAgYSB1biB1c3VhcmlvXHJcbiAgYXN5bmMgZ3JhbnRYUChcclxuICAgIHVzZXJJZDogc3RyaW5nLCBcclxuICAgIGFtb3VudDogbnVtYmVyLCBcclxuICAgIHNvdXJjZTogWFBHYWluWydzb3VyY2UnXSwgXHJcbiAgICBzb3VyY2VJZDogc3RyaW5nLCBcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICApOiBQcm9taXNlPHsgbGV2ZWxVcDogYm9vbGVhbjsgbmV3TGV2ZWw/OiBMZXZlbDsgbm90aWZpY2F0aW9uczogTm90aWZpY2F0aW9uW10gfT4ge1xyXG4gICAgLy8gRW4gdW5hIGltcGxlbWVudGFjacOzbiByZWFsLCBlc3RvIGludGVyYWN0dWFyw61hIGNvbiBsYSBiYXNlIGRlIGRhdG9zXHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5nZXRVc2VyKHVzZXJJZClcclxuICAgIGNvbnN0IG9sZExldmVsID0gdGhpcy5jYWxjdWxhdGVMZXZlbCh1c2VyLnRvdGFsWHApXHJcbiAgICBcclxuICAgIHVzZXIueHAgKz0gYW1vdW50XHJcbiAgICB1c2VyLnRvdGFsWHAgKz0gYW1vdW50XHJcbiAgICBcclxuICAgIGNvbnN0IG5ld0xldmVsID0gdGhpcy5jYWxjdWxhdGVMZXZlbCh1c2VyLnRvdGFsWHApXHJcbiAgICBjb25zdCBsZXZlbFVwID0gbmV3TGV2ZWwubGV2ZWwgPiBvbGRMZXZlbC5sZXZlbFxyXG4gICAgXHJcbiAgICBjb25zdCBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXSA9IFtdXHJcbiAgICBcclxuICAgIC8vIE5vdGlmaWNhY2nDs24gZGUgWFAgZ2FuYWRvXHJcbiAgICBub3RpZmljYXRpb25zLnB1c2goe1xyXG4gICAgICBpZDogYHhwXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICB1c2VySWQsXHJcbiAgICAgIHR5cGU6ICd4cF9nYWluJyxcclxuICAgICAgdGl0bGU6ICdYUCBHYW5hZG8nLFxyXG4gICAgICBtZXNzYWdlOiBgSGFzIGdhbmFkbyAke2Ftb3VudH0gWFAgcG9yICR7ZGVzY3JpcHRpb259YCxcclxuICAgICAgZGF0YTogeyBhbW91bnQsIHNvdXJjZSwgc291cmNlSWQgfSxcclxuICAgICAgcmVhZDogZmFsc2UsXHJcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICAvLyBTaSBzdWJpw7MgZGUgbml2ZWxcclxuICAgIGlmIChsZXZlbFVwKSB7XHJcbiAgICAgIHVzZXIubGV2ZWwgPSBuZXdMZXZlbC5sZXZlbFxyXG4gICAgICB1c2VyLmNyb2xhcnMgKz0gbmV3TGV2ZWwucmV3YXJkcy5jcm9sYXJzXHJcbiAgICAgIFxyXG4gICAgICBub3RpZmljYXRpb25zLnB1c2goe1xyXG4gICAgICAgIGlkOiBgbGV2ZWxfJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgdXNlcklkLFxyXG4gICAgICAgIHR5cGU6ICdsZXZlbF91cCcsXHJcbiAgICAgICAgdGl0bGU6ICfCoVN1YmlzdGUgZGUgTml2ZWwhJyxcclxuICAgICAgICBtZXNzYWdlOiBgwqFGZWxpY2lkYWRlcyEgQWhvcmEgZXJlcyAke25ld0xldmVsLm5hbWV9IChOaXZlbCAke25ld0xldmVsLmxldmVsfSlgLFxyXG4gICAgICAgIGRhdGE6IHsgbmV3TGV2ZWwsIHJld2FyZHM6IG5ld0xldmVsLnJld2FyZHMgfSxcclxuICAgICAgICByZWFkOiBmYWxzZSxcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgLy8gT3RvcmdhciBiYWRnZXMgZGUgbml2ZWwgc2kgbG9zIGhheVxyXG4gICAgICBpZiAobmV3TGV2ZWwucmV3YXJkcy5iYWRnZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGJhZGdlTmFtZSBvZiBuZXdMZXZlbC5yZXdhcmRzLmJhZGdlcykge1xyXG4gICAgICAgICAgY29uc3QgYmFkZ2UgPSBhd2FpdCB0aGlzLmdyYW50QmFkZ2UodXNlcklkLCBiYWRnZU5hbWUpXHJcbiAgICAgICAgICBpZiAoYmFkZ2UpIHtcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICBpZDogYGJhZGdlXyR7RGF0ZS5ub3coKX1fJHtiYWRnZS5pZH1gLFxyXG4gICAgICAgICAgICAgIHVzZXJJZCxcclxuICAgICAgICAgICAgICB0eXBlOiAnYmFkZ2VfZWFybmVkJyxcclxuICAgICAgICAgICAgICB0aXRsZTogJ8KhTnVldmEgSW5zaWduaWEhJyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiBgSGFzIGRlc2Jsb3F1ZWFkbyBsYSBpbnNpZ25pYTogJHtiYWRnZS5uYW1lfWAsXHJcbiAgICAgICAgICAgICAgZGF0YTogeyBiYWRnZSB9LFxyXG4gICAgICAgICAgICAgIHJlYWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEd1YXJkYXIgY2FtYmlvcyBkZWwgdXN1YXJpb1xyXG4gICAgYXdhaXQgdGhpcy51cGRhdGVVc2VyKHVzZXIpXHJcbiAgICBcclxuICAgIC8vIFJlZ2lzdHJhciBnYW5hbmNpYSBkZSBYUFxyXG4gICAgYXdhaXQgdGhpcy5sb2dYUEdhaW4oe1xyXG4gICAgICBpZDogYHhwXyR7dXNlcklkfV8ke0RhdGUubm93KCl9YCxcclxuICAgICAgdXNlcklkLFxyXG4gICAgICBhbW91bnQsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgc291cmNlSWQsXHJcbiAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGV2ZWxVcCxcclxuICAgICAgbmV3TGV2ZWw6IGxldmVsVXAgPyBuZXdMZXZlbCA6IHVuZGVmaW5lZCxcclxuICAgICAgbm90aWZpY2F0aW9uc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gT3RvcmdhciBiYWRnZSBhIHVuIHVzdWFyaW9cclxuICBhc3luYyBncmFudEJhZGdlKHVzZXJJZDogc3RyaW5nLCBiYWRnZU5hbWU6IHN0cmluZyk6IFByb21pc2U8QmFkZ2UgfCBudWxsPiB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5nZXRVc2VyKHVzZXJJZClcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIHNpIHlhIHRpZW5lIGVsIGJhZGdlXHJcbiAgICBpZiAodXNlci5iYWRnZXMuc29tZShiID0+IGIubmFtZSA9PT0gYmFkZ2VOYW1lKSkge1xyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBiYWRnZSA9IGF3YWl0IHRoaXMuZ2V0QmFkZ2VCeU5hbWUoYmFkZ2VOYW1lKVxyXG4gICAgaWYgKCFiYWRnZSkgcmV0dXJuIG51bGxcclxuICAgIFxyXG4gICAgYmFkZ2UuZWFybmVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgIHVzZXIuYmFkZ2VzLnB1c2goYmFkZ2UpXHJcbiAgICBcclxuICAgIGF3YWl0IHRoaXMudXBkYXRlVXNlcih1c2VyKVxyXG4gICAgXHJcbiAgICByZXR1cm4gYmFkZ2VcclxuICB9XHJcblxyXG4gIC8vIFZlcmlmaWNhciB5IGRlc2Jsb3F1ZWFyIGxvZ3Jvc1xyXG4gIGFzeW5jIGNoZWNrQWNoaWV2ZW1lbnRzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxBY2hpZXZlbWVudFtdPiB7XHJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5nZXRVc2VyKHVzZXJJZClcclxuICAgIGNvbnN0IHVubG9ja2VkQWNoaWV2ZW1lbnRzOiBBY2hpZXZlbWVudFtdID0gW11cclxuICAgIFxyXG4gICAgLy8gT2J0ZW5lciBsb2dyb3MgZGlzcG9uaWJsZXMgcXVlIGVsIHVzdWFyaW8gbm8gaGEgZGVzYmxvcXVlYWRvXHJcbiAgICBjb25zdCBhdmFpbGFibGVBY2hpZXZlbWVudHMgPSBhd2FpdCB0aGlzLmdldEF2YWlsYWJsZUFjaGlldmVtZW50cyh1c2VySWQpXHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgYWNoaWV2ZW1lbnQgb2YgYXZhaWxhYmxlQWNoaWV2ZW1lbnRzKSB7XHJcbiAgICAgIGlmICh0aGlzLmNoZWNrQWNoaWV2ZW1lbnRSZXF1aXJlbWVudHModXNlciwgYWNoaWV2ZW1lbnQpKSB7XHJcbiAgICAgICAgYWNoaWV2ZW1lbnQuZWFybmVkID0gdHJ1ZVxyXG4gICAgICAgIGFjaGlldmVtZW50LmVhcm5lZERhdGUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICBcclxuICAgICAgICAvLyBPdG9yZ2FyIHJlY29tcGVuc2FzIGRlbCBsb2dyb1xyXG4gICAgICAgIGF3YWl0IHRoaXMuZ3JhbnRYUChcclxuICAgICAgICAgIHVzZXJJZCxcclxuICAgICAgICAgIGFjaGlldmVtZW50LnJld2FyZC54cCxcclxuICAgICAgICAgICdhY2hpZXZlbWVudCcsXHJcbiAgICAgICAgICBhY2hpZXZlbWVudC5pZCxcclxuICAgICAgICAgIGBMb2dybyBkZXNibG9xdWVhZG86ICR7YWNoaWV2ZW1lbnQudGl0bGV9YFxyXG4gICAgICAgIClcclxuICAgICAgICBcclxuICAgICAgICB1c2VyLmNyb2xhcnMgKz0gYWNoaWV2ZW1lbnQucmV3YXJkLmNyb2xhcnNcclxuICAgICAgICBcclxuICAgICAgICBpZiAoYWNoaWV2ZW1lbnQucmV3YXJkLmJhZGdlKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmdyYW50QmFkZ2UodXNlcklkLCBhY2hpZXZlbWVudC5yZXdhcmQuYmFkZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHVubG9ja2VkQWNoaWV2ZW1lbnRzLnB1c2goYWNoaWV2ZW1lbnQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHVubG9ja2VkQWNoaWV2ZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVVc2VyKHVzZXIpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB1bmxvY2tlZEFjaGlldmVtZW50c1xyXG4gIH1cclxuXHJcbiAgLy8gVmVyaWZpY2FyIHJlcXVpc2l0b3MgZGUgdW4gbG9ncm9cclxuICBwcml2YXRlIGNoZWNrQWNoaWV2ZW1lbnRSZXF1aXJlbWVudHModXNlcjogVXNlciwgYWNoaWV2ZW1lbnQ6IEFjaGlldmVtZW50KTogYm9vbGVhbiB7XHJcbiAgICBzd2l0Y2ggKGFjaGlldmVtZW50LmlkKSB7XHJcbiAgICAgIGNhc2UgJ2ZpcnN0X2NvdXJzZSc6XHJcbiAgICAgICAgcmV0dXJuIHVzZXIuc3RhdHMuY291cnNlc0NvbXBsZXRlZCA+PSAxXHJcbiAgICAgIGNhc2UgJ2NvdXJzZV9tYXN0ZXInOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLmNvdXJzZXNDb21wbGV0ZWQgPj0gMTBcclxuICAgICAgY2FzZSAnY2hhbGxlbmdlX3dhcnJpb3InOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLmNoYWxsZW5nZXNDb21wbGV0ZWQgPj0gNVxyXG4gICAgICBjYXNlICdmb3J1bV9oZWxwZXInOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLmZvcnVtQW5zd2VycyA+PSAxMFxyXG4gICAgICBjYXNlICdzdHJlYWtfa2VlcGVyJzpcclxuICAgICAgICByZXR1cm4gdXNlci5zdHJlYWsuY3VycmVudCA+PSA3XHJcbiAgICAgIGNhc2UgJ3NvY2lhbF9idXR0ZXJmbHknOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLmZyaWVuZHNDb3VudCA+PSAyMFxyXG4gICAgICBjYXNlICdrbm93bGVkZ2Vfc2hhcmVyJzpcclxuICAgICAgICByZXR1cm4gdXNlci5zdGF0cy5ub3Rlc1VwbG9hZGVkID49IDUwXHJcbiAgICAgIGNhc2UgJ2V2ZW50X2VudGh1c2lhc3QnOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLmV2ZW50c0F0dGVuZGVkID49IDVcclxuICAgICAgY2FzZSAnY2x1Yl9sZWFkZXInOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLmNsdWJzSm9pbmVkID49IDNcclxuICAgICAgY2FzZSAnc3R1ZHlfbWFyYXRob24nOlxyXG4gICAgICAgIHJldHVybiB1c2VyLnN0YXRzLnRvdGFsU3R1ZHlUaW1lID49IDEwMDAgLy8gMTAwMCBtaW51dG9zXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBY3R1YWxpemFyIHJhY2hhIGRpYXJpYVxyXG4gIGFzeW5jIHVwZGF0ZURhaWx5U3RyZWFrKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN0cmVha1VwZGF0ZWQ6IGJvb2xlYW47IG5vdGlmaWNhdGlvbnM6IE5vdGlmaWNhdGlvbltdIH0+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmdldFVzZXIodXNlcklkKVxyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvRGF0ZVN0cmluZygpXHJcbiAgICBjb25zdCBsYXN0QWN0aXZpdHkgPSBuZXcgRGF0ZSh1c2VyLnN0cmVhay5sYXN0QWN0aXZpdHkpLnRvRGF0ZVN0cmluZygpXHJcbiAgICBjb25zdCB5ZXN0ZXJkYXkgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjQgKiA2MCAqIDYwICogMTAwMCkudG9EYXRlU3RyaW5nKClcclxuICAgIFxyXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uczogTm90aWZpY2F0aW9uW10gPSBbXVxyXG4gICAgXHJcbiAgICBpZiAobGFzdEFjdGl2aXR5ID09PSB0b2RheSkge1xyXG4gICAgICAvLyBZYSByZWdpc3Ryw7MgYWN0aXZpZGFkIGhveVxyXG4gICAgICByZXR1cm4geyBzdHJlYWtVcGRhdGVkOiBmYWxzZSwgbm90aWZpY2F0aW9ucyB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChsYXN0QWN0aXZpdHkgPT09IHllc3RlcmRheSkge1xyXG4gICAgICAvLyBDb250aW7DumEgbGEgcmFjaGFcclxuICAgICAgdXNlci5zdHJlYWsuY3VycmVudCArPSAxXHJcbiAgICAgIHVzZXIuc3RyZWFrLmxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICBcclxuICAgICAgaWYgKHVzZXIuc3RyZWFrLmN1cnJlbnQgPiB1c2VyLnN0cmVhay5sb25nZXN0KSB7XHJcbiAgICAgICAgdXNlci5zdHJlYWsubG9uZ2VzdCA9IHVzZXIuc3RyZWFrLmN1cnJlbnRcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gT3RvcmdhciBYUCBwb3IgcmFjaGFcclxuICAgICAgbGV0IHhwUmV3YXJkID0gWFBfUkVXQVJEUy5EQUlMWV9TVFJFQUtcclxuICAgICAgaWYgKHVzZXIuc3RyZWFrLmN1cnJlbnQgJSA3ID09PSAwKSB7XHJcbiAgICAgICAgeHBSZXdhcmQgPSBYUF9SRVdBUkRTLldFRUtMWV9TVFJFQUtcclxuICAgICAgfSBlbHNlIGlmICh1c2VyLnN0cmVhay5jdXJyZW50ICUgMzAgPT09IDApIHtcclxuICAgICAgICB4cFJld2FyZCA9IFhQX1JFV0FSRFMuTU9OVEhMWV9TVFJFQUtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeHBSZXN1bHQgPSBhd2FpdCB0aGlzLmdyYW50WFAoXHJcbiAgICAgICAgdXNlcklkLFxyXG4gICAgICAgIHhwUmV3YXJkLFxyXG4gICAgICAgICdzdHJlYWsnLFxyXG4gICAgICAgICdkYWlseScsXHJcbiAgICAgICAgYFJhY2hhIGRlICR7dXNlci5zdHJlYWsuY3VycmVudH0gZMOtYXNgXHJcbiAgICAgIClcclxuICAgICAgXHJcbiAgICAgIG5vdGlmaWNhdGlvbnMucHVzaCguLi54cFJlc3VsdC5ub3RpZmljYXRpb25zKVxyXG4gICAgICBcclxuICAgICAgLy8gTm90aWZpY2FjacOzbiBkZSByYWNoYVxyXG4gICAgICBpZiAodXNlci5zdHJlYWsuY3VycmVudCAlIDcgPT09IDApIHtcclxuICAgICAgICBub3RpZmljYXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGBzdHJlYWtfJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICB1c2VySWQsXHJcbiAgICAgICAgICB0eXBlOiAnc3RyZWFrX21pbGVzdG9uZScsXHJcbiAgICAgICAgICB0aXRsZTogJ8KhUmFjaGEgU2VtYW5hbCEnLFxyXG4gICAgICAgICAgbWVzc2FnZTogYMKhSW5jcmXDrWJsZSEgSGFzIG1hbnRlbmlkbyB1bmEgcmFjaGEgZGUgJHt1c2VyLnN0cmVhay5jdXJyZW50fSBkw61hc2AsXHJcbiAgICAgICAgICBkYXRhOiB7IHN0cmVhazogdXNlci5zdHJlYWsuY3VycmVudCB9LFxyXG4gICAgICAgICAgcmVhZDogZmFsc2UsXHJcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNlIHJvbXBpw7MgbGEgcmFjaGFcclxuICAgICAgdXNlci5zdHJlYWsuY3VycmVudCA9IDFcclxuICAgICAgdXNlci5zdHJlYWsubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGF3YWl0IHRoaXMudXBkYXRlVXNlcih1c2VyKVxyXG4gICAgXHJcbiAgICByZXR1cm4geyBzdHJlYWtVcGRhdGVkOiB0cnVlLCBub3RpZmljYXRpb25zIH1cclxuICB9XHJcblxyXG4gIC8vIE3DqXRvZG9zIGF1eGlsaWFyZXMgKGVuIHVuYSBpbXBsZW1lbnRhY2nDs24gcmVhbCwgZXN0b3MgaW50ZXJhY3R1YXLDrWFuIGNvbiBsYSBiYXNlIGRlIGRhdG9zKVxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0VXNlcih1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8VXNlcj4ge1xyXG4gICAgLy8gSW1wbGVtZW50YWNpw7NuIG1vY2sgLSBlbiBwcm9kdWNjacOzbiB2ZW5kcsOtYSBkZSBsYSBiYXNlIGRlIGRhdG9zXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQgLSByZXF1aXJlcyBkYXRhYmFzZSBpbnRlZ3JhdGlvbicpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHVwZGF0ZVVzZXIodXNlcjogVXNlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gSW1wbGVtZW50YWNpw7NuIG1vY2sgLSBlbiBwcm9kdWNjacOzbiBhY3R1YWxpemFyw61hIGxhIGJhc2UgZGUgZGF0b3NcclxuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCAtIHJlcXVpcmVzIGRhdGFiYXNlIGludGVncmF0aW9uJylcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9nWFBHYWluKHhwR2FpbjogWFBHYWluKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBJbXBsZW1lbnRhY2nDs24gbW9jayAtIGVuIHByb2R1Y2Npw7NuIGd1YXJkYXLDrWEgZW4gbGEgYmFzZSBkZSBkYXRvc1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkIC0gcmVxdWlyZXMgZGF0YWJhc2UgaW50ZWdyYXRpb24nKVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRCYWRnZUJ5TmFtZShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPEJhZGdlIHwgbnVsbD4ge1xyXG4gICAgLy8gSW1wbGVtZW50YWNpw7NuIG1vY2sgLSBlbiBwcm9kdWNjacOzbiB2ZW5kcsOtYSBkZSBsYSBiYXNlIGRlIGRhdG9zXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQgLSByZXF1aXJlcyBkYXRhYmFzZSBpbnRlZ3JhdGlvbicpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGdldEF2YWlsYWJsZUFjaGlldmVtZW50cyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8QWNoaWV2ZW1lbnRbXT4ge1xyXG4gICAgLy8gSW1wbGVtZW50YWNpw7NuIG1vY2sgLSBlbiBwcm9kdWNjacOzbiB2ZW5kcsOtYSBkZSBsYSBiYXNlIGRlIGRhdG9zXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQgLSByZXF1aXJlcyBkYXRhYmFzZSBpbnRlZ3JhdGlvbicpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2FtaWZpY2F0aW9uU2VydmljZSA9IG5ldyBHYW1pZmljYXRpb25TZXJ2aWNlKClcclxuXHJcbi8vIEV4cG9ydGFyIGZ1bmNpb25lcyBkZSB1dGlsaWRhZFxyXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlVXNlckxldmVsID0gKHRvdGFsWHA6IG51bWJlcik6IExldmVsID0+IHtcclxuICBmb3IgKGxldCBpID0gTEVWRUxTLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBpZiAodG90YWxYcCA+PSBMRVZFTFNbaV0ubWluWHApIHtcclxuICAgICAgcmV0dXJuIExFVkVMU1tpXVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gTEVWRUxTWzBdXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRYcFRvTmV4dExldmVsID0gKGN1cnJlbnRYcDogbnVtYmVyKTogeyBuZWVkZWQ6IG51bWJlcjsgdG90YWw6IG51bWJlciB9ID0+IHtcclxuICBjb25zdCBjdXJyZW50TGV2ZWwgPSBjYWxjdWxhdGVVc2VyTGV2ZWwoY3VycmVudFhwKVxyXG4gIGNvbnN0IG5leHRMZXZlbCA9IExFVkVMUy5maW5kKGwgPT4gbC5sZXZlbCA9PT0gY3VycmVudExldmVsLmxldmVsICsgMSlcclxuICBcclxuICBpZiAoIW5leHRMZXZlbCkge1xyXG4gICAgcmV0dXJuIHsgbmVlZGVkOiAwLCB0b3RhbDogMCB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBuZWVkZWQ6IG5leHRMZXZlbC5taW5YcCAtIGN1cnJlbnRYcCxcclxuICAgIHRvdGFsOiBuZXh0TGV2ZWwubWluWHAgLSBjdXJyZW50TGV2ZWwubWluWHBcclxuICB9XHJcbn0iXSwibmFtZXMiOlsiTEVWRUxTIiwibGV2ZWwiLCJuYW1lIiwibWluWHAiLCJtYXhYcCIsInJld2FyZHMiLCJjcm9sYXJzIiwiYmFkZ2VzIiwiSW5maW5pdHkiLCJYUF9SRVdBUkRTIiwiQ09VUlNFX0xFU1NPTl9DT01QTEVURSIsIkNPVVJTRV9DT01QTEVURSIsIkNIQUxMRU5HRV9DT01QTEVURSIsIkZPUlVNX1FVRVNUSU9OIiwiRk9SVU1fQU5TV0VSIiwiRk9SVU1fQkVTVF9BTlNXRVIiLCJOT1RFX1VQTE9BRCIsIk5PVEVfU0hBUkVEIiwiRVZFTlRfQVRURU5EIiwiQ0xVQl9KT0lOIiwiQ0xVQl9QT1NUIiwiREFJTFlfU1RSRUFLIiwiV0VFS0xZX1NUUkVBSyIsIk1PTlRITFlfU1RSRUFLIiwiQUNISUVWRU1FTlRfVU5MT0NLIiwiQkFER0VfRUFSTiIsIkdhbWlmaWNhdGlvblNlcnZpY2UiLCJjYWxjdWxhdGVMZXZlbCIsInRvdGFsWHAiLCJpIiwibGVuZ3RoIiwiZ2V0WHBUb05leHRMZXZlbCIsImN1cnJlbnRYcCIsImN1cnJlbnRMZXZlbCIsIm5leHRMZXZlbCIsImZpbmQiLCJsIiwibmVlZGVkIiwidG90YWwiLCJncmFudFhQIiwidXNlcklkIiwiYW1vdW50Iiwic291cmNlIiwic291cmNlSWQiLCJkZXNjcmlwdGlvbiIsInVzZXIiLCJnZXRVc2VyIiwib2xkTGV2ZWwiLCJ4cCIsIm5ld0xldmVsIiwibGV2ZWxVcCIsIm5vdGlmaWNhdGlvbnMiLCJwdXNoIiwiaWQiLCJEYXRlIiwibm93IiwidHlwZSIsInRpdGxlIiwibWVzc2FnZSIsImRhdGEiLCJyZWFkIiwiY3JlYXRlZEF0IiwidG9JU09TdHJpbmciLCJiYWRnZU5hbWUiLCJiYWRnZSIsImdyYW50QmFkZ2UiLCJ1cGRhdGVVc2VyIiwibG9nWFBHYWluIiwidGltZXN0YW1wIiwidW5kZWZpbmVkIiwic29tZSIsImIiLCJnZXRCYWRnZUJ5TmFtZSIsImVhcm5lZEF0IiwiY2hlY2tBY2hpZXZlbWVudHMiLCJ1bmxvY2tlZEFjaGlldmVtZW50cyIsImF2YWlsYWJsZUFjaGlldmVtZW50cyIsImdldEF2YWlsYWJsZUFjaGlldmVtZW50cyIsImFjaGlldmVtZW50IiwiY2hlY2tBY2hpZXZlbWVudFJlcXVpcmVtZW50cyIsImVhcm5lZCIsImVhcm5lZERhdGUiLCJyZXdhcmQiLCJzdGF0cyIsImNvdXJzZXNDb21wbGV0ZWQiLCJjaGFsbGVuZ2VzQ29tcGxldGVkIiwiZm9ydW1BbnN3ZXJzIiwic3RyZWFrIiwiY3VycmVudCIsImZyaWVuZHNDb3VudCIsIm5vdGVzVXBsb2FkZWQiLCJldmVudHNBdHRlbmRlZCIsImNsdWJzSm9pbmVkIiwidG90YWxTdHVkeVRpbWUiLCJ1cGRhdGVEYWlseVN0cmVhayIsInRvZGF5IiwidG9EYXRlU3RyaW5nIiwibGFzdEFjdGl2aXR5IiwieWVzdGVyZGF5Iiwic3RyZWFrVXBkYXRlZCIsImxvbmdlc3QiLCJ4cFJld2FyZCIsInhwUmVzdWx0IiwiRXJyb3IiLCJ4cEdhaW4iLCJnYW1pZmljYXRpb25TZXJ2aWNlIiwiY2FsY3VsYXRlVXNlckxldmVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/gamificationService.ts\n"));

/***/ })

});