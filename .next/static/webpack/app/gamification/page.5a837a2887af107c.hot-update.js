"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/gamification/page",{

/***/ "(app-pages-browser)/./src/services/notificationService.ts":
/*!*********************************************!*\
  !*** ./src/services/notificationService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notificationService: function() { return /* binding */ notificationService; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_define_property.js\");\n\nclass NotificationService {\n    async initializeSSE() {\n        try {\n            // Conectar a Server-Sent Events\n            this.eventSource = new EventSource(\"/api/notifications/stream\");\n            this.eventSource.onopen = ()=>{\n                console.log(\"Connected to notification stream\");\n                this.isConnected = true;\n            };\n            this.eventSource.onmessage = (event)=>{\n                try {\n                    const data = JSON.parse(event.data);\n                    if (data.type === \"notification\") {\n                        this.handleNewNotification(data.data);\n                    } else if (data.type === \"connected\") {\n                        console.log(\"SSE connection established\");\n                    }\n                } catch (error) {\n                    console.error(\"Error parsing SSE message:\", error);\n                }\n            };\n            this.eventSource.onerror = (error)=>{\n                console.error(\"SSE connection error:\", error);\n                this.isConnected = false;\n                // Intentar reconectar después de 5 segundos\n                setTimeout(()=>{\n                    var _this_eventSource;\n                    if (((_this_eventSource = this.eventSource) === null || _this_eventSource === void 0 ? void 0 : _this_eventSource.readyState) === EventSource.CLOSED) {\n                        this.initializeSSE();\n                    }\n                }, 5000);\n            };\n        } catch (error) {\n            console.warn(\"SSE not available:\", error);\n            this.isConnected = false;\n        }\n    }\n    async connect() {\n        if (!this.isConnected) {\n            await this.initializeSSE();\n            // Cargar notificaciones existentes\n            await this.loadNotifications();\n        }\n    }\n    disconnect() {\n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n            this.isConnected = false;\n        }\n    }\n    // Cargar notificaciones desde la API\n    async loadNotifications() {\n        try {\n            const response = await fetch(\"/api/notifications\");\n            if (response.ok) {\n                const data = await response.json();\n                this.notifications = data.notifications.map((n)=>({\n                        ...n,\n                        createdAt: new Date(n.createdAt)\n                    }));\n            }\n        } catch (error) {\n            console.error(\"Error loading notifications:\", error);\n        }\n    }\n    handleNewNotification(notification) {\n        // Agregar la notificación a la lista\n        this.notifications.unshift(notification);\n        // Mantener solo las últimas 100 notificaciones\n        if (this.notifications.length > 100) {\n            this.notifications = this.notifications.slice(0, 100);\n        }\n        // Notificar a todos los listeners\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(notification);\n            } catch (error) {\n                console.error(\"Error in notification listener:\", error);\n            }\n        });\n        // Mostrar notificación del navegador si está permitido\n        this.showBrowserNotification(notification);\n    }\n    showBrowserNotification(notification) {\n        if (\"Notification\" in window && Notification.permission === \"granted\") {\n            const browserNotification = new Notification(notification.title, {\n                body: notification.message,\n                icon: \"/favicon.ico\",\n                tag: notification.id\n            });\n            // Auto-cerrar después de 5 segundos\n            setTimeout(()=>{\n                browserNotification.close();\n            }, 5000);\n        }\n    }\n    // Método para simular notificaciones cuando WebSocket no está disponible\n    simulateNotification(notification) {\n        const fullNotification = {\n            ...notification,\n            id: Math.random().toString(36).substr(2, 9),\n            createdAt: new Date(),\n            read: false\n        };\n        this.handleNewNotification(fullNotification);\n    }\n    // Suscribirse a notificaciones\n    subscribe(listener) {\n        this.listeners.push(listener);\n        // Retornar función para desuscribirse\n        return ()=>{\n            const index = this.listeners.indexOf(listener);\n            if (index > -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n    }\n    // Obtener todas las notificaciones\n    getNotifications() {\n        return [\n            ...this.notifications\n        ];\n    }\n    // Obtener notificaciones no leídas\n    getUnreadNotifications() {\n        return this.notifications.filter((n)=>!n.read);\n    }\n    // Marcar notificación como leída\n    async markAsRead(notificationId) {\n        try {\n            const response = await fetch(\"/api/notifications/\".concat(notificationId, \"/read\"), {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                const notification = this.notifications.find((n)=>n.id === notificationId);\n                if (notification) {\n                    notification.read = true;\n                }\n            }\n        } catch (error) {\n            console.error(\"Error marking notification as read:\", error);\n        }\n    }\n    // Marcar todas como leídas\n    async markAllAsRead() {\n        try {\n            const response = await fetch(\"/api/notifications/read-all\", {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                this.notifications.forEach((n)=>n.read = true);\n            }\n        } catch (error) {\n            console.error(\"Error marking all notifications as read:\", error);\n        }\n    }\n    // Eliminar notificación\n    removeNotification(notificationId) {\n        const index = this.notifications.findIndex((n)=>n.id === notificationId);\n        if (index > -1) {\n            this.notifications.splice(index, 1);\n        }\n    }\n    // Limpiar todas las notificaciones\n    clearAll() {\n        this.notifications = [];\n    }\n    // Solicitar permisos para notificaciones del navegador\n    async requestNotificationPermission() {\n        if (\"Notification\" in window) {\n            const permission = await Notification.requestPermission();\n            return permission;\n        }\n        return \"denied\";\n    }\n    // Obtener estado de conexión\n    getConnectionStatus() {\n        return this.isConnected;\n    }\n    // Crear notificación en el servidor\n    async createNotification(type, title, message, data) {\n        try {\n            const response = await fetch(\"/api/notifications\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    type,\n                    title,\n                    message,\n                    data\n                })\n            });\n            if (response.ok) {\n                const notification = await response.json();\n                return notification;\n            }\n        } catch (error) {\n            console.error(\"Error creating notification:\", error);\n        }\n    }\n    // Enviar notificación de XP ganado\n    async notifyXPGained(xp, reason) {\n        await this.createNotification(\"GAMIFICATION\", \"\\xa1XP Ganado!\", \"Has ganado \".concat(xp, \" XP por \").concat(reason), {\n            xp,\n            reason\n        });\n    }\n    // Enviar notificación de subida de nivel\n    async notifyLevelUp(newLevel) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Nivel Alcanzado!\", \"\\xa1Felicidades! Has alcanzado el nivel \".concat(newLevel), {\n            level: newLevel\n        });\n    }\n    // Enviar notificación de badge ganado\n    async notifyBadgeEarned(badgeName) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Badge Desbloqueado!\", \"Has desbloqueado el badge: \".concat(badgeName), {\n            badge: badgeName\n        });\n    }\n    constructor(){\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"eventSource\", null);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"listeners\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"notifications\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_0__._)(this, \"isConnected\", false);\n    // No inicializar automáticamente, esperar a que el usuario se conecte\n    }\n}\n// Instancia singleton\nconst notificationService = new NotificationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9ub3RpZmljYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQVNBLE1BQU1BO0lBVUosTUFBY0MsZ0JBQWdCO1FBQzVCLElBQUk7WUFDRixnQ0FBZ0M7WUFDaEMsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSUMsWUFBWTtZQUVuQyxJQUFJLENBQUNELFdBQVcsQ0FBQ0UsTUFBTSxHQUFHO2dCQUN4QkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1lBQ3JCO1lBRUEsSUFBSSxDQUFDTCxXQUFXLENBQUNNLFNBQVMsR0FBRyxDQUFDQztnQkFDNUIsSUFBSTtvQkFDRixNQUFNQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNILE1BQU1DLElBQUk7b0JBRWxDLElBQUlBLEtBQUtHLElBQUksS0FBSyxnQkFBZ0I7d0JBQ2hDLElBQUksQ0FBQ0MscUJBQXFCLENBQUNKLEtBQUtBLElBQUk7b0JBQ3RDLE9BQU8sSUFBSUEsS0FBS0csSUFBSSxLQUFLLGFBQWE7d0JBQ3BDUixRQUFRQyxHQUFHLENBQUM7b0JBQ2Q7Z0JBQ0YsRUFBRSxPQUFPUyxPQUFPO29CQUNkVixRQUFRVSxLQUFLLENBQUMsOEJBQThCQTtnQkFDOUM7WUFDRjtZQUVBLElBQUksQ0FBQ2IsV0FBVyxDQUFDYyxPQUFPLEdBQUcsQ0FBQ0Q7Z0JBQzFCVixRQUFRVSxLQUFLLENBQUMseUJBQXlCQTtnQkFDdkMsSUFBSSxDQUFDUixXQUFXLEdBQUc7Z0JBRW5CLDRDQUE0QztnQkFDNUNVLFdBQVc7d0JBQ0w7b0JBQUosSUFBSSwwQkFBSSxDQUFDZixXQUFXLGNBQWhCLDBEQUFrQmdCLFVBQVUsTUFBS2YsWUFBWWdCLE1BQU0sRUFBRTt3QkFDdkQsSUFBSSxDQUFDbEIsYUFBYTtvQkFDcEI7Z0JBQ0YsR0FBRztZQUNMO1FBRUYsRUFBRSxPQUFPYyxPQUFPO1lBQ2RWLFFBQVFlLElBQUksQ0FBQyxzQkFBc0JM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cEMsTUFBTSxJQUFJLENBQUNQLGtCQUFrQixDQUMzQixVQUNBLHdCQUNBLDJDQUFpRCxPQUFUTyxXQUN4QztZQUFFQyxPQUFPRDtRQUFTO0lBRXRCO0lBRUEsc0NBQXNDO0lBQ3RDLE1BQU1FLGtCQUFrQkMsU0FBaUIsRUFBRTtRQUN6QyxNQUFNLElBQUksQ0FBQ1Ysa0JBQWtCLENBQzNCLFVBQ0EsMkJBQ0EsOEJBQXdDLE9BQVZVLFlBQzlCO1lBQUVDLE9BQU9EO1FBQVU7SUFFdkI7SUF2UUFFLGFBQWM7UUFMZCxzRUFBUXhGLGVBQWtDO1FBQzFDLHNFQUFRb0MsYUFBb0MsRUFBRTtRQUM5QyxzRUFBUVQsaUJBQWdDLEVBQUU7UUFDMUMsc0VBQVF0QixlQUFjO0lBR3BCLHNFQUFzRTtJQUN4RTtBQXdRRjtBQUVBLHNCQUFzQjtBQUNmLE1BQU1vRixzQkFBc0IsSUFBSTNGLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvbm90aWZpY2F0aW9uU2VydmljZS50cz9mMTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlTm90aWZpY2F0aW9ucyc7XG5cbi8vIFJlLWV4cG9ydGFyIGVsIHRpcG8gcGFyYSB1c28gZXh0ZXJub1xuZXhwb3J0IHR5cGUgeyBOb3RpZmljYXRpb24gfTtcblxuZXhwb3J0IGludGVyZmFjZSBOb3RpZmljYXRpb25MaXN0ZW5lciB7XG4gIChub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbik6IHZvaWQ7XG59XG5cbmNsYXNzIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xuICBwcml2YXRlIGV2ZW50U291cmNlOiBFdmVudFNvdXJjZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGxpc3RlbmVyczogTm90aWZpY2F0aW9uTGlzdGVuZXJbXSA9IFtdO1xuICBwcml2YXRlIG5vdGlmaWNhdGlvbnM6IE5vdGlmaWNhdGlvbltdID0gW107XG4gIHByaXZhdGUgaXNDb25uZWN0ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBObyBpbmljaWFsaXphciBhdXRvbcOhdGljYW1lbnRlLCBlc3BlcmFyIGEgcXVlIGVsIHVzdWFyaW8gc2UgY29uZWN0ZVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU1NFKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25lY3RhciBhIFNlcnZlci1TZW50IEV2ZW50c1xuICAgICAgdGhpcy5ldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL2FwaS9ub3RpZmljYXRpb25zL3N0cmVhbScpO1xuXG4gICAgICB0aGlzLmV2ZW50U291cmNlLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byBub3RpZmljYXRpb24gc3RyZWFtJyk7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbm90aWZpY2F0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVOZXdOb3RpZmljYXRpb24oZGF0YS5kYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTU0UgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIFNTRSBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NTRSBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gSW50ZW50YXIgcmVjb25lY3RhciBkZXNwdcOpcyBkZSA1IHNlZ3VuZG9zXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmV2ZW50U291cmNlPy5yZWFkeVN0YXRlID09PSBFdmVudFNvdXJjZS5DTE9TRUQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNTRSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwMCk7XG4gICAgICB9O1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignU1NFIG5vdCBhdmFpbGFibGU6JywgZXJyb3IpO1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVTU0UoKTtcbiAgICAgIC8vIENhcmdhciBub3RpZmljYWNpb25lcyBleGlzdGVudGVzXG4gICAgICBhd2FpdCB0aGlzLmxvYWROb3RpZmljYXRpb25zKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5ldmVudFNvdXJjZSkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgdGhpcy5ldmVudFNvdXJjZSA9IG51bGw7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FyZ2FyIG5vdGlmaWNhY2lvbmVzIGRlc2RlIGxhIEFQSVxuICBwcml2YXRlIGFzeW5jIGxvYWROb3RpZmljYXRpb25zKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL25vdGlmaWNhdGlvbnMnKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBkYXRhLm5vdGlmaWNhdGlvbnMubWFwKChuOiBhbnkpID0+ICh7XG4gICAgICAgICAgLi4ubixcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKG4uY3JlYXRlZEF0KVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbm90aWZpY2F0aW9uczonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVOZXdOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pIHtcbiAgICAvLyBBZ3JlZ2FyIGxhIG5vdGlmaWNhY2nDs24gYSBsYSBsaXN0YVxuICAgIHRoaXMubm90aWZpY2F0aW9ucy51bnNoaWZ0KG5vdGlmaWNhdGlvbik7XG4gICAgXG4gICAgLy8gTWFudGVuZXIgc29sbyBsYXMgw7psdGltYXMgMTAwIG5vdGlmaWNhY2lvbmVzXG4gICAgaWYgKHRoaXMubm90aWZpY2F0aW9ucy5sZW5ndGggPiAxMDApIHtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IHRoaXMubm90aWZpY2F0aW9ucy5zbGljZSgwLCAxMDApO1xuICAgIH1cblxuICAgIC8vIE5vdGlmaWNhciBhIHRvZG9zIGxvcyBsaXN0ZW5lcnNcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyKG5vdGlmaWNhdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBub3RpZmljYXRpb24gbGlzdGVuZXI6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW9zdHJhciBub3RpZmljYWNpw7NuIGRlbCBuYXZlZ2Fkb3Igc2kgZXN0w6EgcGVybWl0aWRvXG4gICAgdGhpcy5zaG93QnJvd3Nlck5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG93QnJvd3Nlck5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbikge1xuICAgIGlmICgnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdncmFudGVkJykge1xuICAgICAgY29uc3QgYnJvd3Nlck5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24obm90aWZpY2F0aW9uLnRpdGxlLCB7XG4gICAgICAgIGJvZHk6IG5vdGlmaWNhdGlvbi5tZXNzYWdlLFxuICAgICAgICBpY29uOiAnL2Zhdmljb24uaWNvJyxcbiAgICAgICAgdGFnOiBub3RpZmljYXRpb24uaWRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBdXRvLWNlcnJhciBkZXNwdcOpcyBkZSA1IHNlZ3VuZG9zXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgYnJvd3Nlck5vdGlmaWNhdGlvbi5jbG9zZSgpO1xuICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gTcOpdG9kbyBwYXJhIHNpbXVsYXIgbm90aWZpY2FjaW9uZXMgY3VhbmRvIFdlYlNvY2tldCBubyBlc3TDoSBkaXNwb25pYmxlXG4gIHNpbXVsYXRlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogT21pdDxOb3RpZmljYXRpb24sICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdyZWFkJz4pIHtcbiAgICBjb25zdCBmdWxsTm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24gPSB7XG4gICAgICAuLi5ub3RpZmljYXRpb24sXG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgcmVhZDogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVOZXdOb3RpZmljYXRpb24oZnVsbE5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvLyBTdXNjcmliaXJzZSBhIG5vdGlmaWNhY2lvbmVzXG4gIHN1YnNjcmliZShsaXN0ZW5lcjogTm90aWZpY2F0aW9uTGlzdGVuZXIpOiAoKSA9PiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBcbiAgICAvLyBSZXRvcm5hciBmdW5jacOzbiBwYXJhIGRlc3VzY3JpYmlyc2VcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9idGVuZXIgdG9kYXMgbGFzIG5vdGlmaWNhY2lvbmVzXG4gIGdldE5vdGlmaWNhdGlvbnMoKTogTm90aWZpY2F0aW9uW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5ub3RpZmljYXRpb25zXTtcbiAgfVxuXG4gIC8vIE9idGVuZXIgbm90aWZpY2FjaW9uZXMgbm8gbGXDrWRhc1xuICBnZXRVbnJlYWROb3RpZmljYXRpb25zKCk6IE5vdGlmaWNhdGlvbltdIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zLmZpbHRlcihuID0+ICFuLnJlYWQpO1xuICB9XG5cbiAgLy8gTWFyY2FyIG5vdGlmaWNhY2nDs24gY29tbyBsZcOtZGFcbiAgYXN5bmMgbWFya0FzUmVhZChub3RpZmljYXRpb25JZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvbm90aWZpY2F0aW9ucy8ke25vdGlmaWNhdGlvbklkfS9yZWFkYCwge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gdGhpcy5ub3RpZmljYXRpb25zLmZpbmQobiA9PiBuLmlkID09PSBub3RpZmljYXRpb25JZCk7XG4gICAgICAgIGlmIChub3RpZmljYXRpb24pIHtcbiAgICAgICAgICBub3RpZmljYXRpb24ucmVhZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFya2luZyBub3RpZmljYXRpb24gYXMgcmVhZDonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gTWFyY2FyIHRvZGFzIGNvbW8gbGXDrWRhc1xuICBhc3luYyBtYXJrQWxsQXNSZWFkKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL25vdGlmaWNhdGlvbnMvcmVhZC1hbGwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BBVENIJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuZm9yRWFjaChuID0+IG4ucmVhZCA9IHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtYXJraW5nIGFsbCBub3RpZmljYXRpb25zIGFzIHJlYWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVsaW1pbmFyIG5vdGlmaWNhY2nDs25cbiAgcmVtb3ZlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbklkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubm90aWZpY2F0aW9ucy5maW5kSW5kZXgobiA9PiBuLmlkID09PSBub3RpZmljYXRpb25JZCk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIExpbXBpYXIgdG9kYXMgbGFzIG5vdGlmaWNhY2lvbmVzXG4gIGNsZWFyQWxsKCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gU29saWNpdGFyIHBlcm1pc29zIHBhcmEgbm90aWZpY2FjaW9uZXMgZGVsIG5hdmVnYWRvclxuICBhc3luYyByZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbigpOiBQcm9taXNlPE5vdGlmaWNhdGlvblBlcm1pc3Npb24+IHtcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICBjb25zdCBwZXJtaXNzaW9uID0gYXdhaXQgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICByZXR1cm4gcGVybWlzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICdkZW5pZWQnO1xuICB9XG5cbiAgLy8gT2J0ZW5lciBlc3RhZG8gZGUgY29uZXhpw7NuXG4gIGdldENvbm5lY3Rpb25TdGF0dXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQ7XG4gIH1cblxuICAvLyBDcmVhciBub3RpZmljYWNpw7NuIGVuIGVsIHNlcnZpZG9yXG4gIGFzeW5jIGNyZWF0ZU5vdGlmaWNhdGlvbih0eXBlOiBOb3RpZmljYXRpb25bJ3R5cGUnXSwgdGl0bGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvbm90aWZpY2F0aW9ucycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgZGF0YVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBub3RpZmljYXRpb247XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIG5vdGlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gRW52aWFyIG5vdGlmaWNhY2nDs24gZGUgWFAgZ2FuYWRvXG4gIGFzeW5jIG5vdGlmeVhQR2FpbmVkKHhwOiBudW1iZXIsIHJlYXNvbjogc3RyaW5nKSB7XG4gICAgYXdhaXQgdGhpcy5jcmVhdGVOb3RpZmljYXRpb24oXG4gICAgICAnR0FNSUZJQ0FUSU9OJyxcbiAgICAgICfCoVhQIEdhbmFkbyEnLFxuICAgICAgYEhhcyBnYW5hZG8gJHt4cH0gWFAgcG9yICR7cmVhc29ufWAsXG4gICAgICB7IHhwLCByZWFzb24gfVxuICAgICk7XG4gIH1cblxuICAvLyBFbnZpYXIgbm90aWZpY2FjacOzbiBkZSBzdWJpZGEgZGUgbml2ZWxcbiAgYXN5bmMgbm90aWZ5TGV2ZWxVcChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgYXdhaXQgdGhpcy5jcmVhdGVOb3RpZmljYXRpb24oXG4gICAgICAnU1lTVEVNJyxcbiAgICAgICfCoU5pdmVsIEFsY2FuemFkbyEnLFxuICAgICAgYMKhRmVsaWNpZGFkZXMhIEhhcyBhbGNhbnphZG8gZWwgbml2ZWwgJHtuZXdMZXZlbH1gLFxuICAgICAgeyBsZXZlbDogbmV3TGV2ZWwgfVxuICAgICk7XG4gIH1cblxuICAvLyBFbnZpYXIgbm90aWZpY2FjacOzbiBkZSBiYWRnZSBnYW5hZG9cbiAgYXN5bmMgbm90aWZ5QmFkZ2VFYXJuZWQoYmFkZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZU5vdGlmaWNhdGlvbihcbiAgICAgICdTWVNURU0nLFxuICAgICAgJ8KhQmFkZ2UgRGVzYmxvcXVlYWRvIScsXG4gICAgICBgSGFzIGRlc2Jsb3F1ZWFkbyBlbCBiYWRnZTogJHtiYWRnZU5hbWV9YCxcbiAgICAgIHsgYmFkZ2U6IGJhZGdlTmFtZSB9XG4gICAgKTtcbiAgfVxuXG5cbn1cblxuLy8gSW5zdGFuY2lhIHNpbmdsZXRvblxuZXhwb3J0IGNvbnN0IG5vdGlmaWNhdGlvblNlcnZpY2UgPSBuZXcgTm90aWZpY2F0aW9uU2VydmljZSgpOyJdLCJuYW1lcyI6WyJOb3RpZmljYXRpb25TZXJ2aWNlIiwiaW5pdGlhbGl6ZVNTRSIsImV2ZW50U291cmNlIiwiRXZlbnRTb3VyY2UiLCJvbm9wZW4iLCJjb25zb2xlIiwibG9nIiwiaXNDb25uZWN0ZWQiLCJvbm1lc3NhZ2UiLCJldmVudCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJ0eXBlIiwiaGFuZGxlTmV3Tm90aWZpY2F0aW9uIiwiZXJyb3IiLCJvbmVycm9yIiwic2V0VGltZW91dCIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJ3YXJuIiwiY29ubmVjdCIsImxvYWROb3RpZmljYXRpb25zIiwiZGlzY29ubmVjdCIsImNsb3NlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwianNvbiIsIm5vdGlmaWNhdGlvbnMiLCJtYXAiLCJuIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIm5vdGlmaWNhdGlvbiIsInVuc2hpZnQiLCJsZW5ndGgiLCJzbGljZSIsImxpc3RlbmVycyIsImZvckVhY2giLCJsaXN0ZW5lciIsInNob3dCcm93c2VyTm90aWZpY2F0aW9uIiwid2luZG93IiwiTm90aWZpY2F0aW9uIiwicGVybWlzc2lvbiIsImJyb3dzZXJOb3RpZmljYXRpb24iLCJ0aXRsZSIsImJvZHkiLCJtZXNzYWdlIiwiaWNvbiIsInRhZyIsImlkIiwic2ltdWxhdGVOb3RpZmljYXRpb24iLCJmdWxsTm90aWZpY2F0aW9uIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwicmVhZCIsInN1YnNjcmliZSIsInB1c2giLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJnZXROb3RpZmljYXRpb25zIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9ucyIsImZpbHRlciIsIm1hcmtBc1JlYWQiLCJub3RpZmljYXRpb25JZCIsIm1ldGhvZCIsImZpbmQiLCJtYXJrQWxsQXNSZWFkIiwicmVtb3ZlTm90aWZpY2F0aW9uIiwiZmluZEluZGV4IiwiY2xlYXJBbGwiLCJyZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbiIsInJlcXVlc3RQZXJtaXNzaW9uIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsImNyZWF0ZU5vdGlmaWNhdGlvbiIsImhlYWRlcnMiLCJzdHJpbmdpZnkiLCJub3RpZnlYUEdhaW5lZCIsInhwIiwicmVhc29uIiwibm90aWZ5TGV2ZWxVcCIsIm5ld0xldmVsIiwibGV2ZWwiLCJub3RpZnlCYWRnZUVhcm5lZCIsImJhZGdlTmFtZSIsImJhZGdlIiwiY29uc3RydWN0b3IiLCJub3RpZmljYXRpb25TZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/notificationService.ts\n"));

/***/ })

});