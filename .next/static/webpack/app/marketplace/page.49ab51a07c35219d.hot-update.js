"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/marketplace/page",{

/***/ "(app-pages-browser)/./src/services/notificationService.ts":
/*!*********************************************!*\
  !*** ./src/services/notificationService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   notificationService: function() { return /* binding */ notificationService; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/_/_define_property */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_define_property.js\");\n/* harmony import */ var _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hooks/useNotifications */ \"(app-pages-browser)/./src/hooks/useNotifications.ts\");\n\n\nclass NotificationService {\n    async initializeSSE() {\n        try {\n            // Conectar a Server-Sent Events\n            this.eventSource = new EventSource(\"/api/notifications/stream\");\n            this.eventSource.onopen = ()=>{\n                console.log(\"Connected to notification stream\");\n                this.isConnected = true;\n            };\n            this.eventSource.onmessage = (event)=>{\n                try {\n                    const data = JSON.parse(event.data);\n                    if (data.type === \"notification\") {\n                        this.handleNewNotification(data.data);\n                    } else if (data.type === \"connected\") {\n                        console.log(\"SSE connection established\");\n                    }\n                } catch (error) {\n                    console.error(\"Error parsing SSE message:\", error);\n                }\n            };\n            this.eventSource.onerror = (error)=>{\n                console.error(\"SSE connection error:\", error);\n                this.isConnected = false;\n                // Intentar reconectar después de 5 segundos\n                setTimeout(()=>{\n                    var _this_eventSource;\n                    if (((_this_eventSource = this.eventSource) === null || _this_eventSource === void 0 ? void 0 : _this_eventSource.readyState) === EventSource.CLOSED) {\n                        this.initializeSSE();\n                    }\n                }, 5000);\n            };\n        } catch (error) {\n            console.warn(\"SSE not available:\", error);\n            this.isConnected = false;\n        }\n    }\n    async connect() {\n        if (!this.isConnected) {\n            await this.initializeSSE();\n            // Cargar notificaciones existentes\n            await this.loadNotifications();\n        }\n    }\n    disconnect() {\n        if (this.eventSource) {\n            this.eventSource.close();\n            this.eventSource = null;\n            this.isConnected = false;\n        }\n    }\n    // Cargar notificaciones desde la API\n    async loadNotifications() {\n        try {\n            const response = await fetch(\"/api/notifications\");\n            if (response.ok) {\n                const data = await response.json();\n                this.notifications = data.notifications.map((n)=>({\n                        ...n,\n                        createdAt: new Date(n.createdAt)\n                    }));\n            }\n        } catch (error) {\n            console.error(\"Error loading notifications:\", error);\n        }\n    }\n    handleNewNotification(notification) {\n        // Agregar la notificación a la lista\n        this.notifications.unshift(notification);\n        // Mantener solo las últimas 100 notificaciones\n        if (this.notifications.length > 100) {\n            this.notifications = this.notifications.slice(0, 100);\n        }\n        // Notificar a todos los listeners\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(notification);\n            } catch (error) {\n                console.error(\"Error in notification listener:\", error);\n            }\n        });\n        // Mostrar notificación del navegador si está permitido\n        this.showBrowserNotification(notification);\n    }\n    showBrowserNotification(notification) {\n        if (\"Notification\" in window && _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__.Notification.permission === \"granted\") {\n            const browserNotification = new _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__.Notification(notification.title, {\n                body: notification.message,\n                icon: \"/favicon.ico\",\n                tag: notification.id\n            });\n            // Auto-cerrar después de 5 segundos\n            setTimeout(()=>{\n                browserNotification.close();\n            }, 5000);\n        }\n    }\n    // Método para simular notificaciones cuando WebSocket no está disponible\n    simulateNotification(notification) {\n        const fullNotification = {\n            ...notification,\n            id: Math.random().toString(36).substr(2, 9),\n            createdAt: new Date(),\n            read: false\n        };\n        this.handleNewNotification(fullNotification);\n    }\n    // Suscribirse a notificaciones\n    subscribe(listener) {\n        this.listeners.push(listener);\n        // Retornar función para desuscribirse\n        return ()=>{\n            const index = this.listeners.indexOf(listener);\n            if (index > -1) {\n                this.listeners.splice(index, 1);\n            }\n        };\n    }\n    // Obtener todas las notificaciones\n    getNotifications() {\n        return [\n            ...this.notifications\n        ];\n    }\n    // Obtener notificaciones no leídas\n    getUnreadNotifications() {\n        return this.notifications.filter((n)=>!n.read);\n    }\n    // Marcar notificación como leída\n    async markAsRead(notificationId) {\n        try {\n            const response = await fetch(\"/api/notifications/\".concat(notificationId, \"/read\"), {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                const notification = this.notifications.find((n)=>n.id === notificationId);\n                if (notification) {\n                    notification.read = true;\n                }\n            }\n        } catch (error) {\n            console.error(\"Error marking notification as read:\", error);\n        }\n    }\n    // Marcar todas como leídas\n    async markAllAsRead() {\n        try {\n            const response = await fetch(\"/api/notifications/read-all\", {\n                method: \"PATCH\"\n            });\n            if (response.ok) {\n                this.notifications.forEach((n)=>n.read = true);\n            }\n        } catch (error) {\n            console.error(\"Error marking all notifications as read:\", error);\n        }\n    }\n    // Eliminar notificación\n    removeNotification(notificationId) {\n        const index = this.notifications.findIndex((n)=>n.id === notificationId);\n        if (index > -1) {\n            this.notifications.splice(index, 1);\n        }\n    }\n    // Limpiar todas las notificaciones\n    clearAll() {\n        this.notifications = [];\n    }\n    // Solicitar permisos para notificaciones del navegador\n    async requestNotificationPermission() {\n        if (\"Notification\" in window) {\n            const permission = await _hooks_useNotifications__WEBPACK_IMPORTED_MODULE_0__.Notification.requestPermission();\n            return permission;\n        }\n        return \"denied\";\n    }\n    // Obtener estado de conexión\n    getConnectionStatus() {\n        return this.isConnected;\n    }\n    // Crear notificación en el servidor\n    async createNotification(type, title, message, data) {\n        try {\n            const response = await fetch(\"/api/notifications\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    type,\n                    title,\n                    message,\n                    data\n                })\n            });\n            if (response.ok) {\n                const notification = await response.json();\n                return notification;\n            }\n        } catch (error) {\n            console.error(\"Error creating notification:\", error);\n        }\n    }\n    // Enviar notificación de XP ganado\n    async notifyXPGained(xp, reason) {\n        await this.createNotification(\"GAMIFICATION\", \"\\xa1XP Ganado!\", \"Has ganado \".concat(xp, \" XP por \").concat(reason), {\n            xp,\n            reason\n        });\n    }\n    // Enviar notificación de subida de nivel\n    async notifyLevelUp(newLevel) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Nivel Alcanzado!\", \"\\xa1Felicidades! Has alcanzado el nivel \".concat(newLevel), {\n            level: newLevel\n        });\n    }\n    // Enviar notificación de badge ganado\n    async notifyBadgeEarned(badgeName) {\n        await this.createNotification(\"SYSTEM\", \"\\xa1Badge Desbloqueado!\", \"Has desbloqueado el badge: \".concat(badgeName), {\n            badge: badgeName\n        });\n    }\n    constructor(){\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"eventSource\", null);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"listeners\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"notifications\", []);\n        (0,_swc_helpers_define_property__WEBPACK_IMPORTED_MODULE_1__._)(this, \"isConnected\", false);\n    // No inicializar automáticamente, esperar a que el usuario se conecte\n    }\n}\n// Instancia singleton\nconst notificationService = new NotificationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9ub3RpZmljYXRpb25TZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUQ7QUFNekQsTUFBTUM7SUFVSixNQUFjQyxnQkFBZ0I7UUFDNUIsSUFBSTtZQUNGLGdDQUFnQztZQUNoQyxJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJQyxZQUFZO1lBRW5DLElBQUksQ0FBQ0QsV0FBVyxDQUFDRSxNQUFNLEdBQUc7Z0JBQ3hCQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFDckI7WUFFQSxJQUFJLENBQUNMLFdBQVcsQ0FBQ00sU0FBUyxHQUFHLENBQUNDO2dCQUM1QixJQUFJO29CQUNGLE1BQU1DLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUMsSUFBSTtvQkFFbEMsSUFBSUEsS0FBS0csSUFBSSxLQUFLLGdCQUFnQjt3QkFDaEMsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0osS0FBS0EsSUFBSTtvQkFDdEMsT0FBTyxJQUFJQSxLQUFLRyxJQUFJLEtBQUssYUFBYTt3QkFDcENSLFFBQVFDLEdBQUcsQ0FBQztvQkFDZDtnQkFDRixFQUFFLE9BQU9TLE9BQU87b0JBQ2RWLFFBQVFVLEtBQUssQ0FBQyw4QkFBOEJBO2dCQUM5QztZQUNGO1lBRUEsSUFBSSxDQUFDYixXQUFXLENBQUNjLE9BQU8sR0FBRyxDQUFDRDtnQkFDMUJWLFFBQVFVLEtBQUssQ0FBQyx5QkFBeUJBO2dCQUN2QyxJQUFJLENBQUNSLFdBQVcsR0FBRztnQkFFbkIsNENBQTRDO2dCQUM1Q1UsV0FBVzt3QkFDTDtvQkFBSixJQUFJLDBCQUFJLENBQUNmLFdBQVcsY0FBaEIsMERBQWtCZ0IsVUFBVSxNQUFLZixZQUFZZ0IsTUFBTSxFQUFFO3dCQUN2RCxJQUFJLENBQUNsQixhQUFhO29CQUNwQjtnQkFDRixHQUFHO1lBQ0w7UUFFRixFQUFFLE9BQU9jLE9BQU87WUFDZFYsUUFBUWUsSUFBSSxDQUFD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RUFBRTtRQUNwQyxNQUFNLElBQUksQ0FBQ1Asa0JBQWtCLENBQzNCLFVBQ0Esd0JBQ0EsMkNBQWlELE9BQVRPLFdBQ3hDO1lBQUVDLE9BQU9EO1FBQVM7SUFFdEI7SUFFQSxzQ0FBc0M7SUFDdEMsTUFBTUUsa0JBQWtCQyxTQUFpQixFQUFFO1FBQ3pDLE1BQU0sSUFBSSxDQUFDVixrQkFBa0IsQ0FDM0IsVUFDQSwyQkFDQSw4QkFBd0MsT0FBVlUsWUFDOUI7WUFBRUMsT0FBT0Q7UUFBVTtJQUV2QjtJQXZRQUUsYUFBYztRQUxkLHNFQUFRdkYsZUFBa0M7UUFDMUMsc0VBQVFvQyxhQUFvQyxFQUFFO1FBQzlDLHNFQUFRVCxpQkFBZ0MsRUFBRTtRQUMxQyxzRUFBUXRCLGVBQWM7SUFHcEIsc0VBQXNFO0lBQ3hFO0FBd1FGO0FBRUEsc0JBQXNCO0FBQ2YsTUFBTW1GLHNCQUFzQixJQUFJMUYsc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9ub3RpZmljYXRpb25TZXJ2aWNlLnRzP2YxODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlTm90aWZpY2F0aW9ucyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uTGlzdGVuZXIge1xuICAobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pOiB2b2lkO1xufVxuXG5jbGFzcyBOb3RpZmljYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBldmVudFNvdXJjZTogRXZlbnRTb3VyY2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IE5vdGlmaWNhdGlvbkxpc3RlbmVyW10gPSBbXTtcbiAgcHJpdmF0ZSBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXSA9IFtdO1xuICBwcml2YXRlIGlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gTm8gaW5pY2lhbGl6YXIgYXV0b23DoXRpY2FtZW50ZSwgZXNwZXJhciBhIHF1ZSBlbCB1c3VhcmlvIHNlIGNvbmVjdGVcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVNTRSgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uZWN0YXIgYSBTZXJ2ZXItU2VudCBFdmVudHNcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9hcGkvbm90aWZpY2F0aW9ucy9zdHJlYW0nKTtcblxuICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gbm90aWZpY2F0aW9uIHN0cmVhbScpO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ25vdGlmaWNhdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTmV3Tm90aWZpY2F0aW9uKGRhdGEuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU1NFIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBTU0UgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTU0UgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIEludGVudGFyIHJlY29uZWN0YXIgZGVzcHXDqXMgZGUgNSBzZWd1bmRvc1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5ldmVudFNvdXJjZT8ucmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTU0UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMDApO1xuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1NTRSBub3QgYXZhaWxhYmxlOicsIGVycm9yKTtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplU1NFKCk7XG4gICAgICAvLyBDYXJnYXIgbm90aWZpY2FjaW9uZXMgZXhpc3RlbnRlc1xuICAgICAgYXdhaXQgdGhpcy5sb2FkTm90aWZpY2F0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuY2xvc2UoKTtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhcmdhciBub3RpZmljYWNpb25lcyBkZXNkZSBsYSBBUElcbiAgcHJpdmF0ZSBhc3luYyBsb2FkTm90aWZpY2F0aW9ucygpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zJyk7XG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0gZGF0YS5ub3RpZmljYXRpb25zLm1hcCgobjogYW55KSA9PiAoe1xuICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShuLmNyZWF0ZWRBdClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG5vdGlmaWNhdGlvbnM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTmV3Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uKSB7XG4gICAgLy8gQWdyZWdhciBsYSBub3RpZmljYWNpw7NuIGEgbGEgbGlzdGFcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb24pO1xuICAgIFxuICAgIC8vIE1hbnRlbmVyIHNvbG8gbGFzIMO6bHRpbWFzIDEwMCBub3RpZmljYWNpb25lc1xuICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSB0aGlzLm5vdGlmaWNhdGlvbnMuc2xpY2UoMCwgMTAwKTtcbiAgICB9XG5cbiAgICAvLyBOb3RpZmljYXIgYSB0b2RvcyBsb3MgbGlzdGVuZXJzXG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcihub3RpZmljYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbm90aWZpY2F0aW9uIGxpc3RlbmVyOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1vc3RyYXIgbm90aWZpY2FjacOzbiBkZWwgbmF2ZWdhZG9yIHNpIGVzdMOhIHBlcm1pdGlkb1xuICAgIHRoaXMuc2hvd0Jyb3dzZXJOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvd0Jyb3dzZXJOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pIHtcbiAgICBpZiAoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXJOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbi50aXRsZSwge1xuICAgICAgICBib2R5OiBub3RpZmljYXRpb24ubWVzc2FnZSxcbiAgICAgICAgaWNvbjogJy9mYXZpY29uLmljbycsXG4gICAgICAgIHRhZzogbm90aWZpY2F0aW9uLmlkXG4gICAgICB9KTtcblxuICAgICAgLy8gQXV0by1jZXJyYXIgZGVzcHXDqXMgZGUgNSBzZWd1bmRvc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGJyb3dzZXJOb3RpZmljYXRpb24uY2xvc2UoKTtcbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIE3DqXRvZG8gcGFyYSBzaW11bGFyIG5vdGlmaWNhY2lvbmVzIGN1YW5kbyBXZWJTb2NrZXQgbm8gZXN0w6EgZGlzcG9uaWJsZVxuICBzaW11bGF0ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb246IE9taXQ8Tm90aWZpY2F0aW9uLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAncmVhZCc+KSB7XG4gICAgY29uc3QgZnVsbE5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uID0ge1xuICAgICAgLi4ubm90aWZpY2F0aW9uLFxuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIHJlYWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlTmV3Tm90aWZpY2F0aW9uKGZ1bGxOb3RpZmljYXRpb24pO1xuICB9XG5cbiAgLy8gU3VzY3JpYmlyc2UgYSBub3RpZmljYWNpb25lc1xuICBzdWJzY3JpYmUobGlzdGVuZXI6IE5vdGlmaWNhdGlvbkxpc3RlbmVyKTogKCkgPT4gdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgXG4gICAgLy8gUmV0b3JuYXIgZnVuY2nDs24gcGFyYSBkZXN1c2NyaWJpcnNlXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBPYnRlbmVyIHRvZGFzIGxhcyBub3RpZmljYWNpb25lc1xuICBnZXROb3RpZmljYXRpb25zKCk6IE5vdGlmaWNhdGlvbltdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubm90aWZpY2F0aW9uc107XG4gIH1cblxuICAvLyBPYnRlbmVyIG5vdGlmaWNhY2lvbmVzIG5vIGxlw61kYXNcbiAgZ2V0VW5yZWFkTm90aWZpY2F0aW9ucygpOiBOb3RpZmljYXRpb25bXSB7XG4gICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9ucy5maWx0ZXIobiA9PiAhbi5yZWFkKTtcbiAgfVxuXG4gIC8vIE1hcmNhciBub3RpZmljYWNpw7NuIGNvbW8gbGXDrWRhXG4gIGFzeW5jIG1hcmtBc1JlYWQobm90aWZpY2F0aW9uSWQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL25vdGlmaWNhdGlvbnMvJHtub3RpZmljYXRpb25JZH0vcmVhZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHRoaXMubm90aWZpY2F0aW9ucy5maW5kKG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbm90aWZpY2F0aW9uLnJlYWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1hcmtpbmcgbm90aWZpY2F0aW9uIGFzIHJlYWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1hcmNhciB0b2RhcyBjb21vIGxlw61kYXNcbiAgYXN5bmMgbWFya0FsbEFzUmVhZCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9ub3RpZmljYXRpb25zL3JlYWQtYWxsJywge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmZvckVhY2gobiA9PiBuLnJlYWQgPSB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWFya2luZyBhbGwgbm90aWZpY2F0aW9ucyBhcyByZWFkOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbGltaW5hciBub3RpZmljYWNpw7NuXG4gIHJlbW92ZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb25JZDogc3RyaW5nKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm5vdGlmaWNhdGlvbnMuZmluZEluZGV4KG4gPT4gbi5pZCA9PT0gbm90aWZpY2F0aW9uSWQpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBMaW1waWFyIHRvZGFzIGxhcyBub3RpZmljYWNpb25lc1xuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBbXTtcbiAgfVxuXG4gIC8vIFNvbGljaXRhciBwZXJtaXNvcyBwYXJhIG5vdGlmaWNhY2lvbmVzIGRlbCBuYXZlZ2Fkb3JcbiAgYXN5bmMgcmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24oKTogUHJvbWlzZTxOb3RpZmljYXRpb25QZXJtaXNzaW9uPiB7XG4gICAgaWYgKCdOb3RpZmljYXRpb24nIGluIHdpbmRvdykge1xuICAgICAgY29uc3QgcGVybWlzc2lvbiA9IGF3YWl0IE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgICAgcmV0dXJuIHBlcm1pc3Npb247XG4gICAgfVxuICAgIHJldHVybiAnZGVuaWVkJztcbiAgfVxuXG4gIC8vIE9idGVuZXIgZXN0YWRvIGRlIGNvbmV4acOzblxuICBnZXRDb25uZWN0aW9uU3RhdHVzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xuICB9XG5cbiAgLy8gQ3JlYXIgbm90aWZpY2FjacOzbiBlbiBlbCBzZXJ2aWRvclxuICBhc3luYyBjcmVhdGVOb3RpZmljYXRpb24odHlwZTogTm90aWZpY2F0aW9uWyd0eXBlJ10sIHRpdGxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL25vdGlmaWNhdGlvbnMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBub3RpZmljYXRpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVudmlhciBub3RpZmljYWNpw7NuIGRlIFhQIGdhbmFkb1xuICBhc3luYyBub3RpZnlYUEdhaW5lZCh4cDogbnVtYmVyLCByZWFzb246IHN0cmluZykge1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKFxuICAgICAgJ0dBTUlGSUNBVElPTicsXG4gICAgICAnwqFYUCBHYW5hZG8hJyxcbiAgICAgIGBIYXMgZ2FuYWRvICR7eHB9IFhQIHBvciAke3JlYXNvbn1gLFxuICAgICAgeyB4cCwgcmVhc29uIH1cbiAgICApO1xuICB9XG5cbiAgLy8gRW52aWFyIG5vdGlmaWNhY2nDs24gZGUgc3ViaWRhIGRlIG5pdmVsXG4gIGFzeW5jIG5vdGlmeUxldmVsVXAobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKFxuICAgICAgJ1NZU1RFTScsXG4gICAgICAnwqFOaXZlbCBBbGNhbnphZG8hJyxcbiAgICAgIGDCoUZlbGljaWRhZGVzISBIYXMgYWxjYW56YWRvIGVsIG5pdmVsICR7bmV3TGV2ZWx9YCxcbiAgICAgIHsgbGV2ZWw6IG5ld0xldmVsIH1cbiAgICApO1xuICB9XG5cbiAgLy8gRW52aWFyIG5vdGlmaWNhY2nDs24gZGUgYmFkZ2UgZ2FuYWRvXG4gIGFzeW5jIG5vdGlmeUJhZGdlRWFybmVkKGJhZGdlTmFtZTogc3RyaW5nKSB7XG4gICAgYXdhaXQgdGhpcy5jcmVhdGVOb3RpZmljYXRpb24oXG4gICAgICAnU1lTVEVNJyxcbiAgICAgICfCoUJhZGdlIERlc2Jsb3F1ZWFkbyEnLFxuICAgICAgYEhhcyBkZXNibG9xdWVhZG8gZWwgYmFkZ2U6ICR7YmFkZ2VOYW1lfWAsXG4gICAgICB7IGJhZGdlOiBiYWRnZU5hbWUgfVxuICAgICk7XG4gIH1cblxuXG59XG5cbi8vIEluc3RhbmNpYSBzaW5nbGV0b25cbmV4cG9ydCBjb25zdCBub3RpZmljYXRpb25TZXJ2aWNlID0gbmV3IE5vdGlmaWNhdGlvblNlcnZpY2UoKTsiXSwibmFtZXMiOlsiTm90aWZpY2F0aW9uIiwiTm90aWZpY2F0aW9uU2VydmljZSIsImluaXRpYWxpemVTU0UiLCJldmVudFNvdXJjZSIsIkV2ZW50U291cmNlIiwib25vcGVuIiwiY29uc29sZSIsImxvZyIsImlzQ29ubmVjdGVkIiwib25tZXNzYWdlIiwiZXZlbnQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwidHlwZSIsImhhbmRsZU5ld05vdGlmaWNhdGlvbiIsImVycm9yIiwib25lcnJvciIsInNldFRpbWVvdXQiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwid2FybiIsImNvbm5lY3QiLCJsb2FkTm90aWZpY2F0aW9ucyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsImpzb24iLCJub3RpZmljYXRpb25zIiwibWFwIiwibiIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3RpZmljYXRpb24iLCJ1bnNoaWZ0IiwibGVuZ3RoIiwic2xpY2UiLCJsaXN0ZW5lcnMiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJzaG93QnJvd3Nlck5vdGlmaWNhdGlvbiIsIndpbmRvdyIsInBlcm1pc3Npb24iLCJicm93c2VyTm90aWZpY2F0aW9uIiwidGl0bGUiLCJib2R5IiwibWVzc2FnZSIsImljb24iLCJ0YWciLCJpZCIsInNpbXVsYXRlTm90aWZpY2F0aW9uIiwiZnVsbE5vdGlmaWNhdGlvbiIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInJlYWQiLCJzdWJzY3JpYmUiLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZ2V0Tm90aWZpY2F0aW9ucyIsImdldFVucmVhZE5vdGlmaWNhdGlvbnMiLCJmaWx0ZXIiLCJtYXJrQXNSZWFkIiwibm90aWZpY2F0aW9uSWQiLCJtZXRob2QiLCJmaW5kIiwibWFya0FsbEFzUmVhZCIsInJlbW92ZU5vdGlmaWNhdGlvbiIsImZpbmRJbmRleCIsImNsZWFyQWxsIiwicmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24iLCJyZXF1ZXN0UGVybWlzc2lvbiIsImdldENvbm5lY3Rpb25TdGF0dXMiLCJjcmVhdGVOb3RpZmljYXRpb24iLCJoZWFkZXJzIiwic3RyaW5naWZ5Iiwibm90aWZ5WFBHYWluZWQiLCJ4cCIsInJlYXNvbiIsIm5vdGlmeUxldmVsVXAiLCJuZXdMZXZlbCIsImxldmVsIiwibm90aWZ5QmFkZ2VFYXJuZWQiLCJiYWRnZU5hbWUiLCJiYWRnZSIsImNvbnN0cnVjdG9yIiwibm90aWZpY2F0aW9uU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/notificationService.ts\n"));

/***/ })

});